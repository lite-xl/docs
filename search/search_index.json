{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lite XL - Fast, Lightweight and Powerful Text-Editing Experience","text":""},{"location":"#headline","title":"Fast, Lightweight and Powerful Text-Editing Experience","text":"<p>A simple, fast, feature-filled and extremely extensible text editor written in C and Lua, adapted from lite.</p> <p> </p>"},{"location":"#all-the-things-you-want-for-editing","title":"All the things you want for editing.","text":"<ul> <li> <p> Lightweight</p> <p>Lite XL is super lightweight; 10 MB of RAM and no GPU requirements at all. If your platform is supported by SDL2, it will work.</p> </li> <li> <p> Powerful</p> <p>Lite XL is powerful and has many features of a \"modern\" text editor. Multiline editing, autocomplete and pane splitting are supported by default.</p> </li> <li> <p> Hackable</p> <p>Lite XL is insanely hackable \u2014 there are no rigid plugin API to hold you back. Override anything and everything, do whatever you want.</p> </li> </ul> <ul> <li> <p> Customizable</p> <p>Lite XL is extremely customizable, completely scriptable with Lua. In fact, most of Lite XL is written entirely in Lua, C is only used when necessary.</p> </li> <li> <p> Hyperextensible</p> <p>If Lite XL doesn't provide a feature you want, it's probably available with a plugin. Add and remove features from your editor at will.</p> </li> </ul>"},{"location":"#lets-get-started","title":"Let's get started.","text":"<ul> <li> <p> Install</p> <p>Learn how to install Lite XL from the official release, package managers and from source.</p> <p> Set Up</p> </li> <li> <p> Customize</p> <p>Learn how to use Lite XL and customize it to suit your needs.</p> <p> User Guide</p> </li> <li> <p> Learn</p> <p>Learn how to add functionality to Lite XL by writing themes and plugins!</p> <p> Developer Guide</p> </li> </ul>"},{"location":"about/contributors/","title":"Contributors","text":"<p>This is a list of people with more than 2 commits to Lite XL. The actual number of contributors is far, far greater than what we're able to list here, including plugins, themes, LPM and bug hunters and beta testers. We deeply appreciate the effort you have put into making Lite XL better.</p> <p>You can get the contributors for a particular release on the release page.</p> Name Contributions rxi Development of the original lite editor. Francesco Creator of lite-xl fork from rxi/lite. Adam Maintainer, renderer enhancements, multi-language syntax highlighting and many other improvements. Guldoman Maintainer, IME support, various bug fixes and performance improvements. Jefferson Gonz\u00e1lez LSP and widget toolkit, syntax highlighting improvements and many other contributions. Takase NagView, Process API improvements and various bug fixes for Windows. redtide Continuous integration, build scripts and the website. Jan Build system maintenance, dirmonitor improvements and bug fixes. Jipok Text editing improvements and bug fixes. liquidev Tab style and animations improvements. Cukmekerb Syntax highlighting improvements. Nils Kvist Popup window replacement with CommandView dialog. vqn Syntax highlighting and other bug fixes. George Timofeev macOS keymap and build improvements. sammyette Various bug fixes for plugins and the editor itself. Daniel Rocha Scaling and indentation fixes. Julien Voisin Security and memory related fixes. sefidel Build system improvements. xwii Tokenizer and code refactoring improvements. Dheison Gomes Code refactoring improvements. Bj\u00f6rn Buckwalter macOS keymap improvements. Ferdinand Prantl macOS stability improvements. Joshua Minor Theming and documentation improvements. ThaCuber Text overwriting and other improvements. SwissalpS LogView and documentation fixes. Evgeny Petrovskiy Syntax highlighting and Windows stability improvements. Cyriaque Skrapits Styling and Python syntax highlighting improvements. Nightwing Markdown syntax highlighting improvements. Janis-Leuenberger Add keymap bindings help file and macOS testing. Mat Mariani Help for macOS port. Some resources taken from mathewmariani/lite-macos. daubaris Initial implementation of Xft.dpi query using xrdb command. Robert \u0160tojs Continuous integration configuration. Aqil Contractor Text rendering enhancement, bug hunter and tester."},{"location":"about/faq/","title":"FAQ","text":""},{"location":"about/faq/#why-lite-xl","title":"Why Lite XL?","text":"<p>Lite XL is a fork of lite, an amazing text editor by rxi. Francesco forked lite to add sub-pixel font rendering, which significantly improves how text looks but brings in huge dependencies (FreeType and AGG) and complicates text rendering. This change was rejected by rxi as lite values simplicity.</p> <p>Eventually, more and more features are added to Lite XL while lite is considered feature complete and only allows bug fixes. Lite XL grew to have slightly different API than lite to support various use cases, such as multiline editing, regular expressions and subsyntaxes.</p>"},{"location":"about/faq/#where-to-find-plugins-and-install-them","title":"Where to find plugins and install them?","text":"<p>You can find a list of plugins at our plugin repository.</p> <p>To install them, you can use LPM. Check out the guide here for more instructions.</p>"},{"location":"about/faq/#is-there-an-easier-way-to-configure-lite-xl-without-learning-lua","title":"Is there an easier way to configure Lite XL without learning Lua?","text":"<p>Yes, since v2.1.0 we provide an extended package with additional plugins which provides a GUI for configuring Lite XL. The packages are prefixed with <code>lite-xl-(version)-addons</code> (e.g. <code>lite-xl-v2.1.0-addons-windows-x86_64.zip</code>).</p>"},{"location":"about/faq/#can-i-get-smart-autocompletion-intellisenselsp","title":"Can I get smart autocompletion (Intellisense/LSP)?","text":"<p>Check out the LSP plugin.</p>"},{"location":"about/faq/#where-is-the-integrated-terminal","title":"Where is the integrated terminal?","text":"<p>You can install lite-xl-terminal.</p>"},{"location":"about/faq/#tabs-and-indent-size","title":"Tabs and indent size?","text":"<p>In your user config (the cog icon in the file tree):</p> <pre><code>config.tab_type = \"soft\" -- soft for spaces, hard for real tabs (\\t)\nconfig.indent_size = 4   -- 4 spaces\n</code></pre>"},{"location":"about/faq/#how-to-enable-line-wrapping","title":"How to enable line wrapping?","text":"<p>Since v2.1.0, you can enable line wrapping by pressing F10. Before v2.1.0, only hard wrapping is supported via autowrap.</p>"},{"location":"about/faq/#how-to-bind-commands-to-keys","title":"How to bind commands to keys?","text":"<pre><code>local keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+escape\"] = \"core:quit\" }\n</code></pre>"},{"location":"about/faq/#how-to-unbind-commands-for-certain-keys","title":"How to unbind commands for certain keys?","text":"<pre><code>-- the second parameter lets you override commands for certain keys\n-- in this case it maps it to nothing\nkeymap.add({ [\"ctrl+escape\"] = {} }, true)\n</code></pre>"},{"location":"about/faq/#how-to-get-commands-for-those-keybinds","title":"How to get commands for those keybinds?","text":"<p>You can search for commands in the command palette.</p> <p>For each command, replace the spaces on the right side with dashes.</p> <p>For example: <code>Core: Find Command</code> \u2192 <code>core:find-command</code></p>"},{"location":"about/faq/#what-version-of-lua-does-lite-xl-use","title":"What version of Lua does Lite XL use?","text":"<p>Lua 5.4 since v2.1.0 and Lua 5.4.2 before v2.1.0. There's some activity around using LuaJIT instead (which is 5.1) but it can provide some Lua 5.2 compatibility. Ongoing work is being done to maintain compatibility between LuaJIT and Lua 5.4, but this is not officially supported.</p>"},{"location":"about/faq/#vim-mode","title":"Vim mode?","text":"<p>You need to vibe.</p>"},{"location":"developer-guide/background-tasks/","title":"Background Tasks","text":"<p>Lite XL performs a few long-running tasks in the background, such as syntax highlighting, project search and filesystem monitoring. Lite XL implements background tasks with Lua coroutines, ensuring that the program runs on a single thread.</p> <p>To schedule a background task for execution, you can use <code>core.add_thread()</code>. This function accepts a coroutine function, a weak reference to an object, and other arguments to pass to the coroutine function.</p> <p>The coroutine function takes any arguments passed into <code>core.add_thread()</code> and should call <code>coroutine.yield()</code> with the timeout in seconds. If the timeout is 0, the coroutine will be resumed as soon as possible.</p> <pre><code>local core = require \"core\"\n\n-- Schedule a function for execution later\ncore.add_thread(function()\n    print(\"Hello world!\")\nend)\n\n-- Schedule a function to run until the weak reference is destroyed\n-- This is used by the syntax highlighter to run the highlighter\n-- until the underlying Doc is destroyed/closed.\ncore.add_thread(function()\n    while true do\n        coroutine.yield(1)\n        print(\"Doc is still open!\")\n    end\nend, doc)\n</code></pre>"},{"location":"developer-guide/background-tasks/#example-managing-a-child-process","title":"Example: Managing a child process","text":"<p>This example uses a background task to manage a long-running child process. The background task reads from the child process and prints it to stdout after the process exits.</p> <pre><code>local core = require \"core\"\n\ncore.add_thread(function()\n    local proc = assert(process.start({ \"cat\", \"/dev/urandom\" }, { stdin = process.REDIRECT_PIPE }))\n\n    local buffer = {}\n    while true do\n        local current_buffer = proc:read()\n        if not current_buffer then break end\n\n        table.insert(buffer, current_buffer)\n        coroutine.yield(0)\n    end\n\n    print(table.concat(buffer))\nend)\n</code></pre>"},{"location":"developer-guide/background-tasks/#example-defer-execution-of-certain-functions","title":"Example: Defer execution of certain functions","text":"<p>This example shows a lesser-known use case for <code>core.add_thread()</code> \u2014 deferring execution until Lite XL is fully loaded. Coroutines scheduled with <code>core.add_thread()</code> will run after the UI and plugins are loaded, so it could be used to run commands added by plugins.</p> <pre><code>local core = require \"core\"\nlocal command = require \"core.command\"\nlocal config = require \"core.config\"\n\ncore.add_thread(function()\n    -- At this points, plugins are not loaded yet.\n    -- We need to defer the execution after the editor is loaded.\n    command:perform \"my-plugin:show\"\nend)\n</code></pre> <p>Background tasks will not execute when Lite XL is unfocused.</p> <p>To work around this, set <code>core.redraw</code> to true before yielding <code>0</code>. This will force Lite XL to constantly redraw (which increases CPU usage), but will make background tasks run correctly.</p>"},{"location":"developer-guide/child-processes/","title":"Child Processes","text":"<p>Lite XL provides a process API to launch external applications. This API is meant to replace Lua's <code>io.popen</code>, <code>system.exec()</code> and lite's pipe-to-a-file approach.</p> <p>Advantages of this API includes:</p> <ul> <li>Proper argument escaping (arguments are supplied via a table)</li> <li>Non-blocking IO</li> <li>Able to detach processes from Lite XL</li> <li>Does not create temporary files</li> <li>Mostly cross-platform (does not require special code for each shell)</li> <li>Does not create a console window on Windows</li> </ul> <p>Unless you plan to run a command and forget about it, you should stick with the Process API as it provides more features.</p>"},{"location":"developer-guide/child-processes/#example-reading-a-file-with-cat","title":"Example: reading a file with <code>cat</code>","text":"<p>This example uses <code>cat</code> to read a file. This approach is impractical, but it demonstrates the typical usage of the Process API.</p> <pre><code>local core = require \"core\"\n\nlocal filename = \"myfile.lua\"\nlocal proc = process.start { \"cat\", filename }\n\n-- we use core.add_thread so that we don't softlock the editor\n-- while reading the output of the child process.\ncore.add_thread(function()\n  local readbuf = {}\n  while true do\n    -- yield so that the rest of the editor can carry out its tasks\n    -- eg. accepting input, updating the UI\n    coroutine.yield(1)\n\n    -- try to read from the standard output of the process.\n    local read = proc:read_stdout()\n    -- read == nil is a pretty good indication that the pipe is closed\n    -- therefore, no more data can be read.\n    if read == nil then break end\n    if read ~= \"\" then\n      -- if we read something, append it into the table\n      readbuf[#readbuf+1] = read\n    end\n    -- efficiently concatenate all the output into a string\n    local process_output = table.concat(readbuf)\n    -- note: never use core.log(process_output)!\n    -- core.log() accepts the same parameters as string.format(),\n    -- so you risk injecting invalid format strings!\n    core.log(\"read: %s\", process_output)\nend)\n</code></pre>"},{"location":"developer-guide/child-processes/#terms","title":"Terms","text":"<p>To prevent confusion, these terms are used to describe various things:</p> Terms Meaning Child process A process created with Process API via <code>process.start()</code> Parent process The parent process that owns the child. This usually refers to Lite XL. Process Any process (including child and parent processes). Stream An entity used to transfer data between child and parent processes. Think of it as a queue that can only be enqueued and dequeued. Standard input The standard input of most processes, also known as stdin. Standard error The standard error of most processes, also known as stderr. Standard output The standard output of most processes, also known as stdout."},{"location":"developer-guide/child-processes/#using-the-process-api","title":"Using the Process API","text":"<p>To create a child process, use <code>process.start()</code>.</p> <pre><code>local type RedirectType = number\n\nlocal record ProcessOptions\n  timeout: number,\n  cwd: string,\n  stdin: RedirectType,\n  stdout: RedirectType,\n  stderr: RedirectType,\n  env: {string: string}\nend\n\nfunction process.start(program_args: {string} | string,\n                        options: ProcessOptions): Process\nend\n</code></pre> <p>The first argument of the function is a table containing the program name and its arguments. The program name and its arguments need not be escaped as the API does it when necessary.</p> <p>Since v2.1.0, users can provide a string instead of a table as the first argument to prevent the function from escaping them. This may help with legacy software on Windows such as <code>cmd.exe</code>. However, this should not be done on POSIX platforms as the entire string will be treated as the program name and cause issues.</p> <p>Note</p> <p>Before v2.1.0, this table is not escaped on Windows.</p> <p>The second argument specifies options to control process creation.</p> <p><code>timeout</code> is an advisory value that will be used by <code>process:wait()</code> and is optional.</p> <p><code>cwd</code> is the current working directory of the program. If specified, the child process would run as if it was started in the directory.</p> <p><code>stdin</code>, <code>stdout</code> and <code>stderr</code> tells Lite XL how to treat standard input and output of the child process. There are four possible values:</p> <ul> <li><code>process.REDIRECT_DEFAULT</code> is the default behavior. It will be deprecated   in future versions as specifying <code>nil</code> is preferred.</li> <li><code>process.REDIRECT_PIPE</code> allows the Process API to write/read the input/output of the child process.</li> <li><code>process.REDIRECT_PARENT</code> redirects the child process' input/output to the parent.   If <code>stdin</code> has this value, child process will accept input from the parent process' console.   If <code>stdout</code> or <code>stderr</code> has this value, child process will output to the parent process' console.</li> <li><code>process.REDIRECT_DISCARD</code> discards any data to/from child process.</li> <li><code>process.REDIRECT_STDOUT</code> can only be used on <code>stderr</code> and will redirect the child process' standard error   to its standard output.</li> </ul> <p><code>env</code> is a table containing the environment variables for the child process as key-value pairs.</p> <p>Note</p> <p>On POSIX platforms, this table will extend the parent's environment. On Windows with Lite XL version v2.1.1 and below, this table will replace the parent's environment.</p> <p>The function returns a <code>Process</code> object that the user should hold onto until the child process can be safely terminated. If the <code>Process</code> object is garbage-collected, the child process will be killed.</p> <p>Examples:</p> <pre><code>-- run something in the background\nlocal proc = process.start { \"bash\", \"-c\", \"echo hello world\" }\n\n-- start a process and read its output\nlocal proc = process.start({ \"cat\", \"myfile\" }, { stdout = process.REDIRECT_PIPE })\n-- might or might not print something as the child process\n-- might not have written data to the standard output\nprint(proc:read_stdout())\n\n-- start a script with verbose output (accepting options over env vars)\nlocal proc = process.start({ \"./site.rb\" }, { env = { VERBOSE = \"1\" } })\n</code></pre>"},{"location":"developer-guide/child-processes/#reading-from-a-child-process","title":"Reading from a child process","text":"<p>If the child process is created with proper output modes, one can read the standard output/error of the child process with the API.</p> <p>To read from the child process' standard output, use <code>process:read_stdout(len)</code>.</p> <p>To read from the child process' standard error, use <code>process:read_stderr(len)</code>.</p> <pre><code>function process:read_stdout(len?: number): string, string, number end\nfunction process:read_stderr(len?: number): string, string, number end\n</code></pre> <p>The <code>len</code> parameter is optional and is used to specify the maximum number of bytes to read from the stream.</p> <p>These methods return a string with size up to <code>len</code> if data can be read. Otherwise, they will return <code>nil</code>, an error message and the error code.</p> <p>Examples:</p> <pre><code>-- proc is a process with stdout set to process.REDIRECT_PIPE\n-- read default number of bytes (2048) from the process' standard output\nprint(proc:read_stdout())\n\n-- read default number of bytes (2048) from the process' standard error\n-- ensure that stderr of the process is not set to process.REDIRECT_STDOUT!\nprint(proc:read_stderr())\n</code></pre>"},{"location":"developer-guide/child-processes/#waiting-for-a-child-process","title":"Waiting for a child process","text":"<p>You might want to wait for a child process to end.</p> <p>To check if a child process is still running, use <code>process:running()</code>.</p> <p>To wait for a child process to end, use <code>process:wait(time)</code>.</p> <pre><code>function process:running(): boolean end\nfunction process:wait(timeout: number): number, string, number end\n</code></pre> <p><code>process:running()</code> returns a boolean immediately indicating whether the process has ended.</p> <p>Note</p> <p>Do not use <code>process:running()</code> to determine when to stop reading the output of a child process. A child process can end and leave residual data in the stream. Instead, you should call <code>process.read_stdout()</code> or <code>process.read_stderr()</code> until an appropriate error (<code>process.ERROR_PIPE</code>) occurs.</p> <p><code>process:wait(time)</code> will wait for specified number of milliseconds before returning. If the child process has ended, it will return the exit code of the process. If the child process is still running or an error occurred, it will return <code>nil</code> followed by an error message and error code.</p> <p><code>time</code> is time in milliseconds before the method returns. If it is 0, the method returns immediately without waiting for the child process to exit. The parameter can also be <code>process.WAIT_DEADLINE</code> to use the timeout value provided in <code>process.start()</code> or <code>process.WAIT_INFINITE</code> to wait until the child process exits (the default).</p> <p>Examples:</p> <pre><code>-- wait for a process to end\ncore.add_thread(function()\n  while process:running() do\n    coroutine.yield(0)\n    print(\"I am still running\")\n  end\n  print(\"Oh no!\")\nend)\n\n-- wait for a process to end, and print its exit code.\nprint(\"The process exited with the exit code \" .. process:wait(process.WAIT_INFINITE))\n</code></pre>"},{"location":"developer-guide/child-processes/#terminating-a-child-process","title":"Terminating a child process","text":"<p>The Process API allows the user to terminate a child process gracefully or forcefully.</p> <p>Use <code>process:terminate()</code> to terminate a child process gracefully. If it fails, use <code>process:kill()</code> to forcefully terminate it.</p> <pre><code>function process:terminate(): boolean, string, number end\nfunction process:kill(): boolean, string, number end\n</code></pre> <p>On POSIX platforms, <code>process:terminate()</code> sends <code>SIGTERM</code> to the child process while <code>process:kill()</code> sends <code>SIGKILL</code> to the child process.</p> <p>On Windows, <code>process:terminate()</code> uses <code>GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT)</code> to simulate Ctrl+Break. <code>process:kill()</code> uses <code>TerminateProcess()</code> to terminate the process immediately.</p> <p>Note</p> <p><code>process:kill()</code> can only request a process to be killed. On POSIX, signals are delivered asynchronously; a child process can be too busy to process them (e.g. stuck at a blocking <code>read()</code> or <code>write()</code> call). This is the same on Windows except <code>TerminateProcess()</code> will request cancellation of all pending IO operations. This is impossible on POSIX platforms.</p> <p>Examples:</p> <pre><code>-- try to terminate child process\nproc:terminate()\n\n-- wait for child process to end\nif not proc:wait(1000) then\n  -- didn't work, have to terminate it forcefully\n  proc:kill()\nend\n</code></pre>"},{"location":"developer-guide/child-processes/#miscellaneous","title":"Miscellaneous","text":"<p><code>process:pid()</code> can be used to obtain the PID of a child process. It will return <code>0</code> if the process is not running.</p> <p><code>process:returncode()</code> can be used to get the exit code of the child process without calling <code>process:wait()</code>.</p> <p><code>process.strerror()</code> can be used to convert error codes emitted by the process API into human-readable error messages. If an error message is unavailable, <code>nil</code> will be returned.</p> <p><code>process:close_stream()</code> can be used to close the child process' streams.</p> <pre><code>function process:pid(): number end\nfunction process:returncode(): number end\nfunction process.strerror(errcode: number): string end\nfunction process:close_stream(stream: number): number, string, number end\n</code></pre> <p>Note</p> <p><code>process:pid()</code> will not return the correct process ID if the child process ended early.</p>"},{"location":"developer-guide/child-processes/#error-handling","title":"Error handling","text":"<p>The Process API functions and methods will return error messages/codes or throw errors.</p> <p><code>process.start()</code> will throw an error if the program cannot be run. On Windows, this usually results in an error message <code>\"Error creating a process: 2\"</code>.</p> <p><code>process:read()</code>, <code>process:read_stdout()</code>, <code>process:read_stderr()</code> and <code>process:write()</code> may throw errors if:</p> <ul> <li>The child process died.</li> <li>The child process closed their side of the input/output.</li> <li>The input/output is closed via <code>process:close_stream()</code>.</li> </ul> <p>Not all errors are documented here. In general, it is recommended to call the functions with <code>pcall()</code> until this inconsistency is fixed in the future.</p>"},{"location":"developer-guide/classes-and-objects/","title":"Classes and Objects","text":"<p>We've briefly talked about the class implementation used by Lite XL in the introduction. In this article, we'll talk about how to use the implementation efficiently.</p> <p>Note</p> <p>Some methods here will be written differently than in the source code to illustrate how the methods should be called.</p>"},{"location":"developer-guide/classes-and-objects/#creating-classes","title":"Creating classes","text":"<p>Similar to many other languages, all classes extend the <code>Object</code> class. To extend a class, one can use the <code>Object.extend()</code> method.</p> <pre><code>function Object.extend(base_class: Object): Object end\n</code></pre> <p>This method accepts one parameter \u2014 the class to copy. This method will create a copy of a <code>Object</code> that can be extended without affecting the original object.</p> <p>You can now define or override methods and metamethods of this newly created class. To initialize a class, you can override the <code>Object:new()</code> method.</p> <pre><code>-- load the Object class\nlocal Object = require \"core.object\"\n-- since the source class is usually the one you want to copy,\n-- we often simplify it to Object:extend().\n-- This is equivalent to Object.extend(Object).\nlocal Animal = Object:extend()\n-- define a constructor for Animal\nfunction Animal:new()\n  self.type = \"animal\"\nend\n</code></pre> <p>Tip</p> <p><code>Object</code> implements the <code>__tostring()</code> and <code>__call()</code> metamethods. You can override the <code>__tostring()</code> metamethod to return a string that suits your class.</p>"},{"location":"developer-guide/classes-and-objects/#super-class","title":"Super class","text":"<p>You can access the super class via <code>Object.super</code>. For instance, to call the constructor of the super class, you can do:</p> <pre><code>local Object = require \"core.object\"\nlocal Animal = Object:extend()\nfunction Animal:new()\n  self.type = \"animal\"\nend\n\nlocal Dog = Animal:extend()\nfunction Dog:new()\n  -- call the superclass constructor\n  -- note the use of . instead of : and explicitly passing self\n  Dog.super.new(self)\nend\n</code></pre> <p>Note that you must call super class methods with <code>.</code> instead of <code>:</code> and pass <code>self</code> as the first parameter. If you call the method with <code>:</code>, it will call the method with <code>self</code> as <code>super</code>, which is the super class and not the instance.</p>"},{"location":"developer-guide/classes-and-objects/#class-relationships","title":"Class relationships","text":"<p>The <code>Object</code> class also provide utility methods for checking relations between classes and object.</p> <p>To check whether an object is strictly an instance of a class (not an instance of a child class), use <code>Object:is()</code>. To do the inverse, use <code>Object:is_class_of()</code>.</p> <pre><code>function Object:is(class: Object): boolean end\nfunction Object.is_class_of(class: Object, instance: Object): boolean end\n</code></pre> <p><code>Object:is()</code> accepts a parameter \u2014 the class to compare it to. If the object is strictly an instance of the class, the method returns true.</p> <p><code>Object.is_class_of()</code> accepts a class and compares it against an instance of an object. If the object is a strictly an instance of the class, the method returns true.</p> <p>Example:</p> <pre><code>local Animal = Object:extend()\nlocal Dog = Animal:extend()\nlocal Cat = Animal:extend()\nlocal doggo = Dog()\n\nprint(doggo:is(Dog)) -- prints true\nprint(doggo:is(Cat)) -- prints false\nprint(doggo:is(Animal)) -- also prints false\n\n-- note that since we're going to pass Dog as the first parameter,\n-- we might as well as use the colon notation\nprint(Dog:is_class_of(doggo)) -- prints true\nprint(Cat:is_class_of(doggo)) -- prints false\nprint(Animal:is_class_of(doggo)) -- prints false\n</code></pre> <p>To check whether an object is an instance of a class (or an instance of child class), use <code>Object:extends()</code>. To do the inverse, use <code>Object:is_extended_by()</code>.</p> <pre><code>function Object:extends(class: Object): boolean end\nfunction Object.is_extended_by: Object, instance: Object): boolean end\n</code></pre> <p>The methods accept the same parameters as <code>Object:is()</code> and <code>Object:is_class_of()</code>.</p> <pre><code>local Animal = Object:extend()\nlocal Dog = Animal:extend()\nlocal Cat = Animal:extend()\nlocal doggo = Dog()\n\nprint(doggo:extends(Dog)) -- prints true\nprint(doggo:extends(Cat)) -- prints false\nprint(doggo:extends(Animal)) -- prints true\n\n-- note that since we're going to pass Dog as the first parameter,\n-- we might as well as use the colon notation\nprint(Dog:is_extended_by(doggo)) -- prints true\nprint(Cat:is_extended_by(doggo)) -- prints false\nprint(Animal:is_extended_by(doggo)) -- prints true\n</code></pre>"},{"location":"developer-guide/commands/","title":"Commands","text":"<p>As explained in the User Guide, a lot of Lite XL's functionalities are implemented as commands.</p> <p>Each command has a predicate \u2014 a condition to check if Lite XL should run the command. The predicate will return a boolean and other values to be consumed by the command function.</p> <p>The simplest command is a class. This tells Lite XL to check whether the current view is an instance of a class. For instance, one can pass <code>DocView</code> as a predicate so that the command only runs if the user is editing a document.</p> <p>A simpler form of the predicate above is a string that specifies the module to import. Lite XL will import the module and checks whether the current view is an instance of the module. To simplify our previous example, we can simply pass <code>core.docview</code> as a predicate to avoid importing <code>DocView</code> ourselves.</p> <p>The string predicate also supports strict checking \u2014 when the module name ends with <code>!</code>, Lite XL will check whether the current view is an instance of the class and not it's child classes. For instance, passing <code>core.view</code> will match <code>DocView</code> as well as <code>CommandView</code>, but passing <code>core.view!</code> will only match <code>View</code> and not <code>DocView</code>.</p> <p>The class and string predicates returns a boolean, the current view and other values passed into the predicate.</p> <p>Lastly, the predicate could also be a function. This function accepts a variable number of arguments, pass through <code>command.add()</code> and returns a boolean and other values. If the function returns true, the command will be executed. Other values are passed into the command function as arguments. For instance, we can create a predicate like this instead of passing <code>DocView</code> as a predicate:</p> <pre><code>local function predicate()\n  return core.current_view:is(DocView)\nend\n</code></pre>"},{"location":"developer-guide/commands/#adding-commands","title":"Adding commands","text":"<p>To add a command, use <code>command.add()</code>.</p> <pre><code>local type function Predicate(any...): boolean\n\nfunction command.add(predicate: Predicate | string | Object,\n                      commands: {string, Predicate}): () end\n</code></pre> <p>The first argument to <code>command.add()</code> is the predicate. This predicate is set for each command passed to <code>command.add()</code>. If no predicates are required, <code>nil</code> can be passed. The second parameter is a table of functions mapped to each command.</p> <p>Example:</p> <pre><code>local command = require \"core.command\"\nlocal DocView = require \"core.docview\"\n\n-- add \"test:print-message\" which prints a message to stdout\n-- this command will be available at all times\ncommand.add(nil, { [\"test:print-message\"] = function() core.log(\"Hello world!\") end })\n\n-- a predicate function\nlocal function docview_predicate(custom_msg)\n  return core.active_view:is(DocView), core.active_view, true, custom_msg\nend\n\nlocal function print_doc_name(dv, custom_predicate, custom_msg)\n  if not custom_msg then\n    custom_msg = custom_predicate and \"custom predicate used!: %s\" or \"name: %s\"\n  end\n  core.log(custom_msg, dv.doc.filename)\nend\n\n-- add \"test:print-doc-name\" which prints the name of currently opened file\n-- This command will only be available if the user is editing a document.\n-- this will log \"custom predicate used!: &lt;filename&gt;\"\ncommand.add(docview_predicate, { [\"test:print-doc-name\"] = print_doc_name })\n\n-- the line above can be simplified into this\n-- this will log \"name: &lt;filename&gt;\"\ncommand.add(DocView, { [\"test:print-doc-name\"] = print_doc_name })\n\n-- the line above can be simplified into this, removing a require\n-- this will log \"name: &lt;filename&gt;\"\ncommand.add(\"core.docview\", { [\"test:print-doc-name\"] = print_doc_name })\n\n-- if you have subclasses of DocView and don't want to match them,\n-- append a exclamation mark at the end.\n-- this will log \"name: &lt;filename&gt;\"\ncommand.add(\"core.docview!\", { [\"test:print-doc-name\"] = print_doc_name })\n</code></pre>"},{"location":"developer-guide/commands/#running-commands","title":"Running commands","text":"<p>Users can run these commands via the command palette while plugins can run these commands programmatically via <code>command.perform()</code>.</p> <p>If you want to check whether a command can run without running the command, (the command exists and the predicate passed), you can use <code>command.is_valid()</code>.</p> <pre><code>function command.perform(cmd: string, ...: any): boolean end\nfunction command.is_valid(cmd: string, ...: any): boolean end\n</code></pre> <p><code>command.perform()</code> accepts a command as the first parameter. If the command requires other parameters, it can be passed into <code>command.perform()</code>. If a command is found and executed successfully, the function returns <code>true</code>.</p> <p>Example:</p> <pre><code>local command = require \"core.command\"\n\n-- open the command prompt\ncommand.perform \"core:find-command\"\n\n-- assuming we've run the code in the section above,\n-- we can try passing a custom message via command:perform!\ncommand.perform(\"test:print-doc-name\", \"custom message! %s\")\n\n-- command palette should be accessible all the time\n-- prints true\nprint(command.is_valid \"core:find-command\")\n</code></pre>"},{"location":"developer-guide/commands/#utility-functions","title":"Utility functions","text":"<p>To get a prettified name of a command, shown in the command palette, use <code>command.prettify_name()</code>.</p> <pre><code>function command.prettify_name(name: string): string end\n</code></pre> <p>The function accepts a command-like string and returns a prettified command string. All the dashes are replaced with spaces and the first letter of all words are capitalized.</p>"},{"location":"developer-guide/creating-syntaxes/","title":"Creating Syntaxes","text":"<p>Syntax highlighting plugins for Lite XL are Lua files. These define some patterns or regular expressions that match different parts of a given language, assigning token types to each match. These different token types are then given different colors by your chosen color scheme.</p>"},{"location":"developer-guide/creating-syntaxes/#what-syntax-token-types-are-supported","title":"What syntax token types are supported?","text":"<p>The supported syntax token types, defined by <code>lite-xl/core/style.lua</code>, are:</p> <ul> <li><code>normal</code></li> <li><code>symbol</code></li> <li><code>comment</code></li> <li><code>keyword</code></li> <li><code>keyword2</code></li> <li><code>number</code></li> <li><code>literal</code></li> <li><code>string</code></li> <li><code>operator</code></li> <li><code>function</code></li> </ul> <p>In your syntax highlighting plugin, you write patterns to match parts of the language syntax, assigning these token types to matches. You don't have to use them all \u2014 just use as many as you need for your language.</p> <p>Let's walk through an example syntax definition and see how this works.</p>"},{"location":"developer-guide/creating-syntaxes/#example-syntax-ssh-config-files","title":"Example syntax: ssh config files","text":"<p>This is a small, simple example of a syntax definition. It's intended to highlight SSH Config files and looks like this:</p> <pre><code>-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\n\nsyntax.add {\n  files = { \"sshd?/?_?config$\" },\n  comment = '#',\n  patterns = {\n    { pattern = \"#.*\\n\",        type = \"comment\"  },\n    { pattern = \"%d+\",          type = \"number\"   },\n    { pattern = \"[%a_][%w_]*\",  type = \"symbol\"   },\n    { pattern = \"@\",            type = \"operator\" },\n  },\n  symbols = {\n    -- ssh config\n    [\"Host\"]                         = \"function\",\n    [\"ProxyCommand\"]                 = \"function\",\n\n    [\"HostName\"]                     = \"keyword\",\n    [\"IdentityFile\"]                 = \"keyword\",\n    ...\n\n    -- sshd config\n    [\"Subsystem\"]                    = \"keyword2\",\n\n    -- Literals\n    [\"yes\"]      = \"literal\",\n    [\"no\"]       = \"literal\",\n    [\"any\"]      = \"literal\",\n    [\"ask\"]      = \"literal\",\n  },\n}\n</code></pre> <p>Let's take each section in turn and see how it works.</p>"},{"location":"developer-guide/creating-syntaxes/#header","title":"Header","text":"<p>The first line is a Lua comment and tells Lite XL which version this plugin requires. The second imports the <code>core.syntax</code> module to allow us to declare a new syntax:</p> <pre><code>-- mod-version:2 -- lite-xl 2.0\nlocal syntax = require \"core.syntax\"\n</code></pre> <p>We then add a syntax definition to Lite XL with <code>syntax.add {...}</code>. The contents of this definition are covered next.</p>"},{"location":"developer-guide/creating-syntaxes/#files","title":"Files","text":"<p>The <code>files</code> property tells Lite XL which files this syntax should be used for. This is a Lua pattern that matches against the full path of the current file. For example, to match against Markdown files (<code>.md</code> or a <code>.markdown</code> files), you could do this:</p> <pre><code>files = { \"%.md$\", \"%.markdown$\" },\n</code></pre> <p>In our original example, we match against the end of the path rather than the extension, because SSH config files don't have extensions, and we don't want to match all <code>config</code> files. We expect the path for SSH config files to look something like one of these:</p> <ul> <li><code>~/.ssh/config</code></li> <li><code>/etc/ssh/ssh_config</code></li> <li><code>/etc/ssh/sshd_config</code></li> </ul> <p>This pattern matches paths that look like that:</p> <pre><code>files = { \"sshd?/?_?config$\" },\n</code></pre>"},{"location":"developer-guide/creating-syntaxes/#comment","title":"Comment","text":"<p>The <code>comment</code> property is used to tell Lite XL what to insert in order to create a comment. It is not a part of syntax definition. You can also use <code>block_comment</code> to tell Lite XL how to create multiline / block comments.</p>"},{"location":"developer-guide/creating-syntaxes/#patterns","title":"Patterns","text":"<p>A given piece of text can only match one pattern. Once Lite XL decides that a piece of text matches a pattern, it will assign that token type to it and move on. Patterns are tested in the order that they are written in the syntax definition, so the first match will win.</p> <p>Patterns are based on Lua patterns or PCRE2.</p> <p>You may find detailed information on Lua patterns in the Lua Reference Manual. For PCRE, there are various [regex tester websites] that provide documentation.</p> <p>Lua patterns can be used by specifying <code>pattern</code> when defining a pattern, while PCRE can be used by specifying <code>regex</code> when defining a pattern.</p> <p>Each pattern takes one of the following forms:</p>"},{"location":"developer-guide/creating-syntaxes/#simple-pattern","title":"Simple Pattern","text":"<pre><code>{ pattern = \"#.*\\n\",        type = \"comment\" },\n</code></pre> <p>When <code>pattern</code> is a string, Lite XL will test the input against the pattern. If the input matches, Lite XL will assign the given token type to the input.</p> <p>In this case, any line starting with <code>#</code> will be assigned the type <code>comment</code>.</p>"},{"location":"developer-guide/creating-syntaxes/#start-end-pattern","title":"Start &amp; End Pattern","text":"<pre><code>{ pattern = { \"%[\", \"%]\" }, type = \"keyword\" },\n</code></pre> <p>When <code>pattern</code> is a table with 2 elements, Lite XL will use them to test for the start and the end of a range. Everything between the start and the end will be assigned the given token type.</p> <p>In this case, everything between <code>[</code> and <code>]</code> will be assigned the type <code>keyword</code>.</p> <p>However, it does not account for escape sequences. Inputs such as <code>[\\]]</code> will be interpreted wrongly as <code>[\\]</code> and <code>]</code>.</p>"},{"location":"developer-guide/creating-syntaxes/#start-end-pattern-with-escape","title":"Start &amp; End Pattern with Escape","text":"<pre><code>{ pattern = { '\"', '\"', '\\\\' }, type = \"string\" },\n</code></pre> <p>When <code>pattern</code> is a table with 3 elements, Lite XL will use the first two to test for the start and the end of a range. The last element is used to denote an \"escape sequence\". If the text matches the 3<sup>rd</sup> element followed by the 2<sup>nd</sup> element, it will not be interpreted as the end of a range.</p> <p>In this case, everything between <code>\"</code> and <code>\"</code> will be assigned the type <code>string</code>. A <code>string</code> can have escape sequences prefixed with <code>\\</code>.</p> <p>Given the input <code>\"\\\"Hello John\\\"\"</code>, the entire input will be assigned the type <code>string</code>.</p>"},{"location":"developer-guide/creating-syntaxes/#symbols","title":"Symbols","text":"<p>The <code>symbols</code> section allows you to assign token types to particular keywords or strings \u2014 usually reserved words in the language you are highlighting. The token type in this section always take precedence over token types declared in patterns.</p> <p>Note</p> <p>This is not related to the <code>symbol</code> token type.</p> <p>For example this highlights <code>Host</code> using the <code>function</code> token type, <code>HostName</code> as a <code>keyword</code>, <code>yes</code>, <code>no</code>, <code>any</code> and <code>ask</code> as a <code>literal</code>:</p> <pre><code>[\"Host\"]                         = \"function\",\n[\"HostName\"]                     = \"keyword\",\n\n[\"yes\"]      = \"literal\",\n[\"no\"]       = \"literal\",\n[\"any\"]      = \"literal\",\n[\"ask\"]      = \"literal\",\n</code></pre>"},{"location":"developer-guide/creating-syntaxes/#tips-double-check-your-patterns","title":"Tips: double-check your patterns!","text":"<p>There are a few common mistakes that can be made when using the <code>symbols</code> table in conjunction with patterns.</p>"},{"location":"developer-guide/creating-syntaxes/#case-1-spaces-between-two-symbols-tokens","title":"Case 1: Spaces between two <code>symbols</code> tokens","text":"<p>Let's have an example:</p> <pre><code>{ pattern = \"[%a_][%w_]+%s+()[%a_][%w_]+\", type = { \"keyword2\", \"symbol\" } }\n</code></pre> <p>Let's explain the pattern a bit (omitting the empty parentheses):</p> <pre><code>[%a_] = any alphabet and underscore\n[%w_] = any alphabet, number and underscore\n%s = any whitespace character\n\nWORD =\n  [%a_] followed by (1 or more [%w_])\n\npattern =\n  WORD followed by (one or more %s) followed by WORD\n</code></pre> <p>Afterwards, you add an entry <code>[\"my\"] = \"literal\"</code> in the <code>symbols</code> table. You test the syntax with <code>my function</code> and found that <code>\"my\"</code> isn't highlighted as <code>literal</code>. Why did that happen?</p> <p><code>symbols</code> table requires an exact match. If you look carefully, the empty parentheses (<code>()</code>) is placed after the space! This tells Lite XL that <code>WORD followed by (one or more %s)</code> is a token, which will match <code>my</code> (note the space in the match).</p> <p>The fix is to add a <code>normal</code> token for the whitespace between the two tokens:</p> <pre><code>{ pattern = \"[%a_][%w_]+()%s+()[%a_][%w_]+\", type = { \"keyword2\", \"normal\", \"symbol\" } }\n</code></pre>"},{"location":"developer-guide/creating-syntaxes/#case-2-patterns-symbols-tokens","title":"Case 2: Patterns &amp; <code>symbols</code> tokens","text":"<p>One might assume that Lite XL magically matches text against the <code>symbols</code> table. This is not the case.</p> <p>In some languages, people may add a generic pattern to delegate the matching to the <code>symbols</code> table.</p> <pre><code>{ pattern = \"[%a_][%w_]*\", \"symbol\" }\n</code></pre> <p>However, the <code>symbols</code> table may look like this:</p> <pre><code>symbols = {\n  [\"my-symbol\"] = \"function\",\n  [\"..something_else\"] = \"literal\"\n}\n</code></pre> <p><code>\"my-symbol</code> contains a dash (<code>-</code>) and <code>\"..something_else\"</code> contains 2 dots (<code>.</code>). None of the characters are matched by <code>[%a_][%w_]*</code>!</p> <p>Beware of the text you intend to match in the <code>symbols</code> table. If you want to use it, you need to ensure that it matches one of the patterns.</p> <p>The correct patterns are:</p> <pre><code>{ pattern = \"[%a_][%w%-_]*\", \"symbol\" },\n{ pattern = \"%.%.[%a_][%w_]*\", \"symbol\" },\n</code></pre>"},{"location":"developer-guide/creating-syntaxes/#testing-your-new-syntax","title":"Testing Your New Syntax","text":"<p>To test your new syntax highlighting you need to do two things:</p> <ul> <li>Reload the Lite XL core</li> <li>Load a file in your chosen language and see how it looks</li> </ul> <p>To reload the core, you can either restart Lite XL or reload it. To do this, type <code>ctrl+shit+p</code> to open the command palette, then select <code>Core: Restart</code> (or type <code>crr</code> or something similar to match it), then press Enter. You will need to restart the core after any changes you make to the syntax highlighting definition.</p>"},{"location":"developer-guide/creating-syntaxes/#example-advanced-syntax-markdown","title":"Example advanced syntax: Markdown","text":"<p>Note</p> <p>This example has features from 2.1. It is not compatible with older versions of Lite XL.</p> <p>Not all languages are as simple as SSH config files. Markup languages like HTML and Markdown are especially hard to parse correctly. Here's the Markdown syntax file in its full glory:</p> <pre><code>-- mod-version:3\nlocal syntax = require \"core.syntax\"\nlocal style = require \"core.style\"\nlocal core = require \"core\"\n\nlocal initial_color = style.syntax[\"keyword2\"]\n\n-- Add 3 type of font styles for use on markdown files\nfor _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n  local attributes = {}\n  if attr ~= \"bold_italic\" then\n    attributes[attr] = true\n  else\n    attributes[\"bold\"] = true\n    attributes[\"italic\"] = true\n  end\n  -- no way to copy user custom font with additional attributes :(\n  style.syntax_fonts[\"markdown_\"..attr] = renderer.font.load(\n    DATADIR .. \"/fonts/JetBrainsMono-Regular.ttf\",\n    style.code_font:get_size(),\n    attributes\n  )\n  -- also add a color for it\n  style.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\nend\n\nlocal in_squares_match = \"^%[%]\"\nlocal in_parenthesis_match = \"^%(%)\"\n\nsyntax.add {\n  name = \"Markdown\",\n  files = { \"%.md$\", \"%.markdown$\" },\n  block_comment = { \"&lt;!--\", \"--&gt;\" },\n  space_handling = false, -- turn off this feature to handle it our selfs\n  patterns = {\n  ---- Place patterns that require spaces at start to optimize matching speed\n  ---- and apply the %s+ optimization immediately afterwards\n    -- bullets\n    { pattern = \"^%s*%*%s\",                 type = \"number\" },\n    { pattern = \"^%s*%-%s\",                 type = \"number\" },\n    { pattern = \"^%s*%+%s\",                 type = \"number\" },\n    -- numbered bullet\n    { pattern = \"^%s*[0-9]+[%.%)]%s\",       type = \"number\" },\n    -- blockquote\n    { pattern = \"^%s*&gt;+%s\",                 type = \"string\" },\n    -- alternative bold italic formats\n    { pattern = { \"%s___\", \"___%f[%s]\" },   type = \"markdown_bold_italic\" },\n    { pattern = { \"%s__\", \"__%f[%s]\" },     type = \"markdown_bold\" },\n    { pattern = { \"%s_[%S]\", \"_%f[%s]\" },   type = \"markdown_italic\" },\n    -- reference links\n    {\n      pattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n      type = { \"function\", \"number\", \"function\" }\n    },\n    {\n      pattern = \"^%s*%[%^?()[\"..in_squares_match..\"]+()%]:%s+.+\\n\",\n      type = { \"function\", \"number\", \"function\" }\n    },\n    -- optimization\n    { pattern = \"%s+\",                      type = \"normal\" },\n\n  ---- HTML rules imported and adapted from language_html\n  ---- to not conflict with markdown rules\n    -- Inline JS and CSS\n    {\n      pattern = {\n      \"&lt;%s*[sS][cC][rR][iI][pP][tT]%s+[tT][yY][pP][eE]%s*=%s*\" ..\n        \"['\\\"]%a+/[jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT]['\\\"]%s*&gt;\",\n      \"&lt;%s*/[sS][cC][rR][iI][pP][tT]&gt;\"\n      },\n      syntax = \".js\",\n      type = \"function\"\n    },\n    {\n      pattern = {\n      \"&lt;%s*[sS][cC][rR][iI][pP][tT]%s*&gt;\",\n      \"&lt;%s*/%s*[sS][cC][rR][iI][pP][tT]&gt;\"\n      },\n      syntax = \".js\",\n      type = \"function\"\n    },\n    {\n      pattern = {\n      \"&lt;%s*[sS][tT][yY][lL][eE][^&gt;]*&gt;\",\n      \"&lt;%s*/%s*[sS][tT][yY][lL][eE]%s*&gt;\"\n      },\n      syntax = \".css\",\n      type = \"function\"\n    },\n    -- Comments\n    { pattern = { \"&lt;!%-%-\", \"%-%-&gt;\" },   type = \"comment\" },\n    -- Tags\n    { pattern = \"%f[^&lt;]![%a_][%w_]*\",    type = \"keyword2\" },\n    { pattern = \"%f[^&lt;][%a_][%w_]*\",     type = \"function\" },\n    { pattern = \"%f[^&lt;]/[%a_][%w_]*\",    type = \"function\" },\n    -- Attributes\n    {\n      pattern = \"[a-z%-]+%s*()=%s*()\\\".-\\\"\",\n      type = { \"keyword\", \"operator\", \"string\" }\n    },\n    {\n      pattern = \"[a-z%-]+%s*()=%s*()'.-'\",\n      type = { \"keyword\", \"operator\", \"string\" }\n    },\n    {\n      pattern = \"[a-z%-]+%s*()=%s*()%-?%d[%d%.]*\",\n      type = { \"keyword\", \"operator\", \"number\" }\n    },\n    -- Entities\n    { pattern = \"&amp;#?[a-zA-Z0-9]+;\",         type = \"keyword2\" },\n\n  ---- Markdown rules\n    -- math\n    { pattern = { \"%$%$\", \"%$%$\", \"\\\\\"  },  type = \"string\", syntax = \".tex\"},\n    { pattern = { \"%$\", \"%$\", \"\\\\\" },       type = \"string\", syntax = \".tex\"},\n    -- code blocks\n    { pattern = { \"```c++\", \"```\" },        type = \"string\", syntax = \".cpp\" },\n    -- ... there's some other patterns here, but I removed them for brevity\n    { pattern = { \"```lobster\", \"```\" },    type = \"string\", syntax = \".lobster\" },\n    { pattern = { \"```\", \"```\" },           type = \"string\" },\n    { pattern = { \"``\", \"``\" },             type = \"string\" },\n    { pattern = { \"%f[\\\\`]%`[%S]\", \"`\" },   type = \"string\" },\n    -- strike\n    { pattern = { \"~~\", \"~~\" },             type = \"keyword2\" },\n    -- highlight\n    { pattern = { \"==\", \"==\" },             type = \"literal\" },\n    -- lines\n    { pattern = \"^%-%-%-+\\n\",               type = \"comment\" },\n    { pattern = \"^%*%*%*+\\n\",               type = \"comment\" },\n    { pattern = \"^___+\\n\",                  type = \"comment\" },\n    -- bold and italic\n    { pattern = { \"%*%*%*%S\", \"%*%*%*\" },   type = \"markdown_bold_italic\" },\n    { pattern = { \"%*%*%S\", \"%*%*\" },       type = \"markdown_bold\" },\n    -- handle edge case where asterisk can be at end of line and not close\n    {\n      pattern = { \"%f[\\\\%*]%*[%S]\", \"%*%f[^%*]\" },\n      type = \"markdown_italic\"\n    },\n    -- alternative bold italic formats\n    { pattern = \"^___[%s%p%w]+___%s\" ,      type = \"markdown_bold_italic\" },\n    { pattern = \"^__[%s%p%w]+__%s\" ,        type = \"markdown_bold\" },\n    { pattern = \"^_[%s%p%w]+_%s\" ,          type = \"markdown_italic\" },\n    -- heading with custom id\n    {\n      pattern = \"^#+%s[%w%s%p]+(){()#[%w%-]+()}\",\n      type = { \"keyword\", \"function\", \"string\", \"function\" }\n    },\n    -- headings\n    { pattern = \"^#+%s.+\\n\",                type = \"keyword\" },\n    -- superscript and subscript\n    {\n      pattern = \"%^()%d+()%^\",\n      type = { \"function\", \"number\", \"function\" }\n    },\n    {\n      pattern = \"%~()%d+()%~\",\n      type = { \"function\", \"number\", \"function\" }\n    },\n    -- definitions\n    { pattern = \"^:%s.+\",                   type = \"function\" },\n    -- emoji\n    { pattern = \":[a-zA-Z0-9_%-]+:\",        type = \"literal\" },\n    -- images and link\n    {\n      pattern = \"!?%[!?%[()[\"..in_squares_match..\"]+()%]%(()[\"..in_parenthesis_match..\"]+()%)%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n      type = { \"function\", \"string\", \"function\", \"number\", \"function\", \"number\", \"function\" }\n    },\n    {\n      pattern = \"!?%[!?%[?()[\"..in_squares_match..\"]+()%]?%]%(()[\"..in_parenthesis_match..\"]+()%)\",\n      type = { \"function\", \"string\", \"function\", \"number\", \"function\" }\n    },\n    -- reference links\n    {\n      pattern = \"%[()[\"..in_squares_match..\"]+()%] *()%[()[\"..in_squares_match..\"]+()%]\",\n      type = { \"function\", \"string\", \"function\", \"function\", \"number\", \"function\" }\n    },\n    {\n      pattern = \"!?%[%^?()[\"..in_squares_match..\"]+()%]\",\n      type = { \"function\", \"number\", \"function\" }\n    },\n    -- url's and email\n    {\n      pattern = \"&lt;[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+%.[a-zA-Z0-9-.]+&gt;\",\n      type = \"function\"\n    },\n    { pattern = \"&lt;https?://%S+&gt;\",           type = \"function\" },\n    { pattern = \"https?://%S+\",             type = \"function\" },\n    -- optimize consecutive dashes used in tables\n    { pattern = \"%-+\",                      type = \"normal\" },\n  },\n  symbols = { },\n}\n\n-- Adjust the color on theme changes\ncore.add_thread(function()\n  while true do\n    if initial_color ~= style.syntax[\"keyword2\"] then\n      for _, attr in pairs({\"bold\", \"italic\", \"bold_italic\"}) do\n        style.syntax[\"markdown_\"..attr] = style.syntax[\"keyword2\"]\n      end\n      initial_color = style.syntax[\"keyword2\"]\n    end\n    coroutine.yield(1)\n  end\nend)\n</code></pre> <p>It demonstrates a lot of syntax highlighting features that were added to v2.1.0 and some workarounds needed.</p>"},{"location":"developer-guide/creating-syntaxes/#syntax-fonts-since-11610","title":"Syntax fonts (Since 1.16.10)","text":"<p>The syntax allows users to set different font styles (bold, italic, etc.) for different patterns. To change the font style of a token, add a Font to <code>style.syntax_fonts[token_type]</code>.</p> <p>For example:</p> <pre><code>-- will ensure every \"fancysyntax_fancy_token\" is italic\nstyle.syntax_fonts[\"fancysyntax_fancy_token\"] = renderer.font.load(\"myfont.ttf\", 14 * SCALE, { italic = true })\n</code></pre> <p>The markdown example automates this with a for loop.</p> <p>The limitations here are that fonts cannot be copied with different attributes, thus the font path has to be hard-coded. Other than that, abusing <code>style.syntax_fonts</code> may lead to slow performance and high memory consumption. This is very obvious when the user tries to resize the editor with <code>ctrl-scroll</code> or <code>ctrl+</code> and <code>ctrl-</code>. Please use it in moderation.</p>"},{"location":"developer-guide/creating-syntaxes/#space-handling-since-v210","title":"Space handling (since v2.1.0)","text":"<p>By default, Lite XL prepends a pattern <code>{ pattern = \"%s+\", type = \"normal\" }</code> to the syntax. This improves the performance drastically on lines that starts with whitespace (e.g. heavily indented lines). It works by matching the whitespace before other patterns in order to prevent Lite XL from iterating the entire syntax. However, there may be syntaxes that require matching spaces (e.g. Markdown with indented blocks) so this can be disabled by setting <code>space_handling</code> to <code>false.</code></p> <p>Tip</p> <p>To keep the space handling optimization or to support older versions of Lite XL, <code>{ pattern = \"%s+\", type = \"normal\" }</code> can be added after patterns that require space.</p>"},{"location":"developer-guide/creating-syntaxes/#simple-patterns-with-multiple-tokens-v11610","title":"Simple patterns with multiple tokens (v1.16.10)","text":"<p>This is an excerpt taken from the Markdown plugin:</p> <pre><code>local in_squares_match = \"^%[%]\"\n-- reference links\n{\n  pattern = \"^%s*%[%^()[\"..in_squares_match..\"]+()%]: \",\n  type = { \"function\", \"number\", \"function\" }\n},\n</code></pre> <p>Sometimes it makes sense to highlight different parts of a pattern differently. An empty parenthesis (<code>()</code>) in Lua patterns will return the position of the text in the parentheses. This will tell Lite XL when to change the type of token. For instance, <code>^%s*%[%^</code> is <code>\"function\"</code>, <code>[\"..in_squares_match..\"]+</code> is <code>\"number\"</code> and <code>%]:</code> is <code>\"function\"</code>.</p>"},{"location":"developer-guide/creating-syntaxes/#subsyntaxes-since-v11610","title":"Subsyntaxes (Since v1.16.10)","text":"<p>Lite XL supports embedding another syntax into the existing syntax. This is used to support code blocks inside the Markdown syntax.</p> <p>For example: <pre><code>{ pattern = { \"```cpp\", \"```\" },        type = \"string\", syntax = \".cpp\" },\n</code></pre></p> <p>This would highlight <code>```cpp</code> and <code>```</code> with <code>\"string\"</code> while everything inside them will be highlighted with a syntax that matches <code>\".cpp\"</code>.</p>"},{"location":"developer-guide/creating-themes/","title":"Creating Themes","text":"<p>Themes are plugins that modify the <code>style</code> table.</p>"},{"location":"developer-guide/debugging/","title":"Debugging","text":""},{"location":"developer-guide/debugging/#making-stdin-and-stdout-work-on-windows","title":"Making stdin and stdout work on Windows","text":"<p>Before using the interactive debugger, you will need to make sure Lite XL is accessible from the terminal.</p> <p>Due to how Windows GUI and text subsystem works, GUI subsystem programs such as Lite XL does not open stdout by default. To work around this, follow these steps:</p> MSYS2/Cygwin ShellPowerShellcmd.exe <p>Run Lite XL with the following command:</p> <pre><code>$ lite-xl | tee /dev/null\n</code></pre> <p>Run Lite XL with the following command:</p> <pre><code>$ lite-xl | tee -variable null\n</code></pre> <p>Run Lite XL with the following command:</p> <pre><code>$ lite-xl &gt; NUL\n</code></pre>"},{"location":"developer-guide/debugging/#installing-lite-debugger","title":"Installing lite-debugger","text":"<p>lite-debugger can be used to debug Lite XL interactively from the terminal. This plugin is not to be confused with the debugger plugin, which provides debugger integration to Lite XL projects.</p> <p>There are various ways to install lite-debugger:</p> lpmMiqManually <p>To install lite-debugger with lpm, run: <pre><code>$ lpm install lite-debugger\n</code></pre></p> <p>Add <code>lite-debugger</code> to <code>config.plugins.miq.plugins</code>.</p> <pre><code>local config = require \"core.config\"\nconfig.plugins.miq.plugins = {\n'TorchedSammy/Miq',\n'lite-debugger',\n}\n</code></pre> <p>Afterwards, run <code>miq:install</code> to install the plugin.</p> <p>Download lite-debugger into <code>~/.config/lite-xl/plugins/lite-debugger.lua</code>.</p> <p>After installation, Lite XL will print a message indicating that the debugger is loaded. There will also be a noticeable slowdown in terms of responsiveness, as the plugin needs to hook into all function calls in Lua.</p>"},{"location":"developer-guide/debugging/#add-breakpoints-in-your-code","title":"Add breakpoints in your code","text":"<p>To start an interactive debugging session, you need to call <code>command.perform \"debugger:break\"</code> to add a breakpoint.</p> <pre><code>-- mod-version:3\n-- Our example plugin to showcase interactive debugging.\nlocal command = require \"core.command\"\n\ncommand.add(\"core.docview\", {\n    [\"hello:scramble-case\"] = function(dv)\n        dv.doc:replace(function(text)\n            local result = {}\n            local cap = true\n            for c in text:gmatch(\".\") do\n                command.perform \"debugger:break\"\n                result[#result+1] = cap and c:upper() or c:lower()\n                cap = not cap\n            end\n            return table.concat(result)\n        end)\n    end\n})\n</code></pre>"},{"location":"developer-guide/debugging/#using-the-debugger","title":"Using the debugger","text":"<p>When you run <code>hello:scramble-case</code> in the command palette, Lite XL should freeze. A prompt will appear in the terminal:</p> <p></p> <p>You can enter <code>h</code> to get a list of commands for debugging:</p> <pre><code>debugger.lua&gt; h\n  &lt;return&gt; =&gt; re-run last command\n  c(ontinue) =&gt; continue execution\n  b(reak) [[file:]function] =&gt; set breakpoint at specified function\n  d(elete) [index] =&gt; remove breakpoint\n  s(tep) =&gt; step forward by one line (into functions)\n  n(ext) =&gt; step forward by one line (skipping over functions)\n  f(inish) =&gt; step forward until exiting the current function\n  u(p) =&gt; move up the stack by one frame\n  d(own) =&gt; move down the stack by one frame\n  w(here) [line count] =&gt; print source code around the current line\n  e(val) [statement] =&gt; execute the statement\n  p(rint) [expression] =&gt; execute the expression and print the result\n  t(race) =&gt; print the stack trace\n  l(ocals) =&gt; print the function arguments, locals and upvalues.\n  h(elp) =&gt; print this message\n  q(uit) =&gt; halt execution\ndebugger.lua&gt;\n</code></pre> <p>Enter <code>w</code> to see the current location.</p> <pre><code>debugger.lua&gt; w\n 658    dbg_writeln(COLOR_YELLOW..\"debugger.lua: \"..COLOR_RESET..\"Loaded for \".._VERSION..\" (Lite-XL)\")\n 659\n 660    command.add(nil, {\n 661       [\"debugger:break\"] = function()\n 662          dbg()\n 663 =&gt;    end,\n 664    })\ndebugger.lua&gt;\n</code></pre> <p>This is not where we want to be. Enter <code>t</code> to show the current stack trace:</p> <pre><code>debugger.lua&gt; t\nInspecting frame 0\n   0 =&gt; /home/takase/.config/lite-xl/plugins/lite-debugger.lua:663 in field 'perform'\n   1    /home/takase/gh/lite-xl/build/src/data/core/command.lua:147 in chunk at /home/takase/gh/lite-xl/build/src/data/core/command.lua:137\n   2    [C]:-1 in global 'xpcall'\n   3    /home/takase/gh/lite-xl/build/src/data/core/init.lua:1261 in field 'try'\n   4    /home/takase/gh/lite-xl/build/src/data/core/command.lua:169 in field 'perform'\n   5    /home/takase/.config/lite-xl/init.lua:86 in local 'fn'\n   6    /home/takase/gh/lite-xl/build/src/data/core/doc/init.lua:538 in method 'replace_cursor'\n   7    /home/takase/gh/lite-xl/build/src/data/core/doc/init.lua:560 in method 'replace'\n   8    /home/takase/.config/lite-xl/init.lua:82 in field 'perform'\n   9    /home/takase/gh/lite-xl/build/src/data/core/command.lua:144 in chunk at /home/takase/gh/lite-xl/build/src/data/core/command.lua:137\n  10    [C]:-1 in global 'xpcall'\n  11    /home/takase/gh/lite-xl/build/src/data/core/init.lua:1261 in field 'try'\n  12    /home/takase/gh/lite-xl/build/src/data/core/command.lua:169 in field 'perform'\n  13    /home/takase/gh/lite-xl/build/src/data/core/commands/core.lua:72 in local 'submit'\n  14    /home/takase/gh/lite-xl/build/src/data/core/commandview.lua:170 in method 'submit'\n  15    /home/takase/gh/lite-xl/build/src/data/core/commands/command.lua:6 in field 'perform'\n  16    /home/takase/gh/lite-xl/build/src/data/core/command.lua:144 in chunk at /home/takase/gh/lite-xl/build/src/data/core/command.lua:137\n  17    [C]:-1 in global 'xpcall'\n  18    /home/takase/gh/lite-xl/build/src/data/core/init.lua:1261 in field 'try'\n  19    /home/takase/gh/lite-xl/build/src/data/core/command.lua:169 in field 'perform'\n  20    /home/takase/gh/lite-xl/build/src/data/core/keymap.lua:226 in field 'on_key_pressed'\n  21    /home/takase/gh/lite-xl/build/src/data/core/init.lua:1282 in upvalue 'on_event'\n  22    /home/takase/gh/lite-xl/build/src/data/plugins/macro.lua:19 in chunk at /home/takase/gh/lite-xl/build/src/data/plugins/macro.lua:18\n  23    [C]:-1 in global 'xpcall'\n  24    /home/takase/gh/lite-xl/build/src/data/core/init.lua:1261 in field 'try'\n  25    /home/takase/gh/lite-xl/build/src/data/core/init.lua:1360 in upvalue 'core_step'\n  26    /home/takase/gh/lite-xl/build/src/data/plugins/frametime.lua:14 in field 'step'\n  27    /home/takase/gh/lite-xl/build/src/data/core/init.lua:1449 in chunk at /home/takase/gh/lite-xl/build/src/data/core/init.lua:1435\n  28    [string \"local core...\"]:14 in chunk at [string \"local core...\"]:6\n  29    [C]:-1 in global 'xpcall'\n  30    [string \"local core...\"]:6 in chunk at [string \"local core...\"]:0\n</code></pre> <p>We are currently inside <code>lite-debugger</code>, in the handler for the command <code>debugger:break</code>. We need to enter <code>d</code> until we reach frame 5, which is where <code>command.perform \"debugger:break\"</code> is called.</p> <pre><code>debugger.lua&gt; d\nInspecting frame: /home/takase/gh/lite-xl/build/src/data/core/command.lua:147 in chunk at /home/takase/gh/lite-xl/build/src/data/core/command.lua:137\ndebugger.lua&gt; d\nInspecting frame: /home/takase/gh/lite-xl/build/src/data/core/init.lua:1261 in field 'try'\ndebugger.lua&gt; d\nInspecting frame: /home/takase/gh/lite-xl/build/src/data/core/command.lua:169 in field 'perform'\ndebugger.lua&gt; d\nInspecting frame: /home/takase/.config/lite-xl/init.lua:86 in local 'fn'\ndebugger.lua&gt; w\n  81        [\"hello:scramble-case\"] = function(dv)\n  82            dv.doc:replace(function(text)\n  83                local result = {}\n  84                local cap = true\n  85                for c in text:gmatch(\".\") do\n  86 =&gt;                 command.perform \"debugger:break\"\n  87                    result[#result+1] = cap and c:upper() or c:lower()\n  88                    cap = not cap\n  89                end\n  90                return table.concat(result)\n  91            end)\ndebugger.lua&gt;\n</code></pre> <p>Now that we are in the correct scope, we can use <code>l</code> to print all the local variables in the scope.</p> <pre><code>debugger.lua&gt; l\n  c =&gt; \"-\"\n  cap =&gt; false\n  command =&gt; {\"map\" = {\"doc:select-to-start-of-doc\" = {\"predicate\" = function: 0x5c6ed4fd9890, \"perform\" = function: 0x5c6ed4fd9770}, \"status-bar:reset-items\"\n  ...\n  result =&gt; {1 = \"-\"}\n  text =&gt; \"-- put user settings here\\\n-- this module will be loaded after everything else when the application starts\\\n...\"\ndebugger.lua&gt;\n</code></pre> <p>You can use <code>p result</code> to show the value of <code>result</code>. This command also allows executing any Lua expression.</p> <p>To evaluate a Lua expression without printing it, you can use <code>e</code> instead.</p> <pre><code>debugger.lua&gt; p result\nresult =&gt; {1 = \"-\", 2 = \"-\"}\ndebugger.lua&gt; p text:len()\ntext:len() =&gt; 3387\ndebugger.lua&gt; e result[1] = \"abcd\"\ndebugger.lua&gt; p result\nresult =&gt; {1 = \"abcd\", 2 = \"-\"}\ndebugger.lua&gt;\n</code></pre> <p>To continue execution, use <code>c</code>. Since <code>command.perform \"debugger:break\"</code> is called in a loop, the debugger will pause until <code>debugger:break</code> is called again.</p>"},{"location":"developer-guide/debugging/#limitations","title":"Limitations","text":"<p>The debugger cannot set breakpoints by line numbers.</p>"},{"location":"developer-guide/documents/","title":"Documents","text":"<p>Lite XL stores an opened file in a Doc. A Doc contains the file in lines (<code>doc.lines</code>), metadata and various states, including the syntax highlighter (<code>doc.highlighter</code>) and the undo stack.</p>"},{"location":"developer-guide/documents/#creating-docs","title":"Creating Docs","text":"<p>To create a Doc, you usually create instances of it directly. Instead, it is often easier to call <code>core.open_doc()</code>. This function accepts a filename and returns a new Doc if the file is not open, or an existing Doc if the file is already open in the editor.</p> <pre><code>function core.open_doc(filename: string): Doc end\n</code></pre>"},{"location":"developer-guide/documents/#getting-existing-docs","title":"Getting existing Docs","text":"<p>Other than <code>core.open_doc()</code>, you can also access <code>core.docs</code> for a list of opened Docs in the editor. However, you should not modify this table directly but use other functions to interact with it.</p>"},{"location":"developer-guide/documents/#filenames","title":"Filenames","text":"<p>The filename is stored in <code>Doc.filename</code> while the absolute path is stored in <code>Doc.abs_filename</code>. If a Doc doesn't have a name (created by pressing Ctrl+N), <code>Doc.filename</code> is set to <code>\"unsaved\"</code> and <code>Doc.abs_filename</code> is nil.</p>"},{"location":"developer-guide/documents/#changes","title":"Changes","text":"<p>If the Document was changed and the changes are not saved, it is considered \"dirty\". To check if a Doc is dirty, simply call <code>Doc:is_dirty()</code>. To reset the dirty flag, call <code>Doc:clean()</code>.</p>"},{"location":"developer-guide/documents/#undo-redo","title":"Undo &amp; Redo","text":"<p>Doc maintains two stacks, used for undo and redo operations. As an operation is popped from one stack, it is pushed to another. The stacks store insertion, deletion and selection changes. Most Doc functions automatically commit to the undo stack.</p> <p>To undo an operation, call <code>Doc:undo()</code>. To redo an operation, call <code>Doc:redo()</code>.</p>"},{"location":"developer-guide/documents/#positions","title":"Positions","text":"<p>A position within a Doc is represented with two numbers \u2014 the row and column number.</p> <p>To ensure that a position is correct (valid for the current Doc), you can call <code>Doc:sanitize_position()</code>. This function accepts a position and clamps it to the following document, making sure that it is valid.</p>"},{"location":"developer-guide/documents/#transformations","title":"Transformations","text":"<p>Doc provides <code>Doc:position_offset()</code> to translate a position to another (e.g. next word, next character, etc.).</p> <p>The function accepts the input position followed by several arguments. Depending on the types of arguments, different transformations are carried out. The simplest form of the function accepts a byte offset and applies it to the input position. The second form accepts a line and column offset and applies it to the position. The third form accepts a transformation function. The transformation function receives the Doc, as well as other arguments passed to <code>Doc:position_offset()</code>.</p> <p>The function should return the transformed position.</p> <pre><code>-- skip 2 bytes starting from line 1 col 1\n-- if line 1 has 2 characters, then 2, 1 will be returned.\n-- assuming each character takes 1 byte, yada yada \nlocal x, y = doc:position_offset(1, 1, 2)\n\n-- skip 2 lines and 3 cols\n-- returns 3, 5\nlocal x, y = doc:position_offset(1, 2, 2, 3)\n\n---Taken from core/doc/translate.lua\n---This function jumps to the next UTF-8 character.\nlocal function next_char(doc, line, col)\n    repeat\n        line, col = doc:position_offset(line, col, -1)\n    until not common.is_utf8_cont(doc:get_char(line, col))\n    return line, col\nend\n\n-- assuming the line contains 1 wide character (2 bytes per character),\n-- the function will return 1, 3\nlocal x, y = doc:position_offset(1, 1, next_char)\n</code></pre> <p>For convenience, Lite XL provides a few transformation functions out-of-the-box. These functions are UTF-8 aware and should be used whenever possible.</p> <pre><code>local translate = require \"core.doc.translate\"\n\n-- this functions the same as the last example\nlocal x, y = doc:position_offset(1, 1, translate.next_char)\n</code></pre>"},{"location":"developer-guide/documents/#selections","title":"Selections","text":"<p>In Lite XL, selections refer to region of text selected by the user. It is represented by four numbers \u2014 the starting and ending line and column number. These numbers are sorted in operational order; for the word \"Hello\", selecting it from <code>o</code> to <code>H</code> will yield <code>(1, 5, 1, 1)</code> while selecting it from <code>H</code> to <code>o</code> will yield <code>(1, 1, 1, 5)</code>. When displayed to the user, a caret will be drawn at the ending position.</p> <p>A caret is a special selection where the start and end positions are equal.</p> <p>As multiline editing is added to Lite XL, functions that operate on a single selection has been largely obsoleted. These functions now operate on the last selection made by the user.</p>"},{"location":"developer-guide/documents/#fixing-inconsistencies","title":"Fixing inconsistencies","text":"<p>As the Doc is being edited, some selections can be invalidated (e.g. the actual lines are shorter than what the selection covers). To fix this, you can call <code>Doc:sanitize_selection()</code> before operating on them. This function will normalize any inconsistent selections within the Doc.</p>"},{"location":"developer-guide/documents/#getting-selections","title":"Getting selections","text":"<p>To check whether the user made any selection (excluding carets), you can use <code>Doc:has_any_selection()</code>.</p> <p>To iterate through all the selections, you can use <code>Doc:get_selections()</code>. This function accepts two arguments <code>sort_intra</code> and <code>idx_reverse</code>.</p> <p>If <code>sort_intra</code> is true, the positions returned by the iterator is sorted in ascending order instead of operational order. If <code>idx_reverse</code> is true, the iterator will iterate from the latest to the oldest selection. When a number is passed to <code>idx_reverse</code>, the iterator will run for that number of iterations from the latest to the oldest.</p> <p>To get individual selections, you can use <code>Doc:get_selection_idx()</code>. This function accepts the selection index (1 is the oldest selection), and optionally a boolean indicating the result positions should be sorted in ascending order.</p> <p>To get text from multiple selections, use <code>Doc:get_selection_text()</code>. This function returns the last <code>limit</code> selections' text concatenated with newline characters. If <code>limit</code> is not provided, the function returns text from all selections.</p> <pre><code>-- iterate through all the selections from oldest to newest\nfor idx, line1, col1, line2, col2 in doc:get_selections(true) do\n    if line1 == line2 and col1 == col2 then\n        print(string.format(\"cursor[%d]: %d, %d\", idx, line1, col1)\n    else\n        print(string.format(\"selection[%d]: %d, %d -&gt; %d, %d\", idx, line1, col1, line2, col2))\n    end\nend\n\n-- get the 2nd selection\nlocal l1, c1, l2, c2 = doc:get_selection_idx(2, true)\n\n-- the text from the first 5 selections\n-- Don't pass anything to get text from all selections\nlocal text = doc:get_selection_text(5)\n</code></pre>"},{"location":"developer-guide/documents/#modifying-selections","title":"Modifying selections","text":"<p>To add a selection, you can use <code>Doc:add_selection()</code>. This function accepts the start and end positions followed by a boolean indicating whether the function should swap the start and end positions. This function will replace an existing smaller selection.</p> <p>To modify an existing selection, you can use <code>Doc:set_selections()</code>. The function can be called with 3, 6 or 7 arguments. The first argument is always the index of the selection to modify.</p> <p>When the function is called with 3 arguments, the other two arguments are the ending positions of the selection. This effectively truncates the selection at the index.</p> <p>When the function is called with 6 arguments, the selection index is followed by the start and end positions of the selection and a boolean indicating whether the start and end positions should be swapped.</p> <p>The 7<sup>th</sup> argument is the number of selections to remove at the index before inserting new ones.</p> <pre><code>-- add a selection\ndoc:add_selection(1, 1, 2, 1)\n\n-- add an empty selection (a caret)\ndoc:add_selection(1, 1)\n\n-- truncate the 2nd selection and move it to 1, 1\n-- (convert a selection into a caret)\ndoc:set_selections(2, 1, 1)\n\n-- move the selection to (1, 1, 10, 10)\ndoc:set_selections(2, 1, 1, 10, 10)\n</code></pre>"},{"location":"developer-guide/documents/#removing-selections","title":"Removing selections","text":"<p>To remove a selection, you can use <code>Doc:remove_selection()</code>. This function accepts a selection index.</p> <pre><code>-- you can't delete while iterating\nlocal indices = {}\nfor idx, l1, c1, l2, c2 in doc:get_selections() do\n    if l1 == whatever_we_want and c1 == whatever_we_want then\n        table.insert(indices, idx)\n    end\nend\n\n-- as things are getting removed, we need to account for the shift\nlocal offset = 0\nfor _, idx in ipairs(indices) do\n    doc:remove_selection(idx - offset)\n    offset = offset + 1\nend\n</code></pre>"},{"location":"developer-guide/documents/#merging-selections","title":"Merging selections","text":"<p>Sometimes operations involving multiline editing can cause inconsistent and duplicated selections. To fix this, you can call <code>Doc:merge_cursors()</code>.</p> <p>This function takes an optional number <code>idx</code>, which will make the function merge selections adjacent to <code>idx</code>.  If <code>idx</code> is not provided, the function attempts to merge all the selections.</p>"},{"location":"developer-guide/documents/#indentation","title":"Indentation","text":"<p>Doc stores the current indentation type and level. This value is either inherited from <code>config.tab_type</code> and <code>config.indent_size</code> or set by the <code>autoindent</code> plugin.</p> <p>To get this info, you can call <code>Doc:get_indent_info()</code>. This function returns the indent type, indent size and whether this is a guess by the <code>autoindent</code> plugin or is confirmed to be correct.</p> <p>Alternatively, you can call <code>Doc:get_indent_string()</code> to get a string used to indent a line by one level.</p> <pre><code>-- indent_type is either \"soft\" for space or \"hard\" for tabs.\n-- indent_size is the number of spaces for soft indentation or the number\n-- of spaces represented by one hard indent.\nlocal indent_type, indent_size, confirmed = doc:get_indent_info()\n\n-- a few space characters for soft indent, a tab character for hard indent\nprint(doc:get_indent_string())\n</code></pre> <pre><code>function Doc:get_indent_info(): \"soft\"|\"hard\", number, boolean end\n</code></pre>"},{"location":"developer-guide/documents/#changing-indentation","title":"Changing indentation","text":"<p>To add or remove indentation, you can call <code>Doc:indent_text()</code>. The function accepts a boolean indicating whether you want to add or remove indents, optionally followed by the starting and ending position of the region to modify.</p> <p>When indenting, if the cursor is in the beginning whitespace of a line, the cursor will insert an appropriate amount of whitespace and move to the first non-whitespace character of the line. Otherwise, whitespace are inserted, and the cursor does not move.</p> <p>When removing indentation, the cursor will jump to the start of line and remove an appropriate amount of whitespace.</p> <pre><code>-- indent all selections\n-- FIXME: this might not indent correctly with selections spanning multiple lines\nfor idx, l1, c1, l2, c2 in doc:get_selections(true) do\n    local new_l1, new_c1, new_l2, new_c2 = doc:indent_text(true, l1, c1, l2, c2)\n    if new_l1 then\n        doc:set_selections(idx, new_l1, new_c1, new_l2, new_c2)\n    end\nend\n</code></pre>"},{"location":"developer-guide/documents/#getting-text","title":"Getting text","text":"<p>To get text from a Doc, you can use <code>Doc:get_text()</code>. This function accepts the start and end position and returns text between it.</p> <p><code>Doc:get_char()</code> can be used to get the character at a specified line and column.</p>"},{"location":"developer-guide/documents/#modifying-text","title":"Modifying text","text":"<p>Doc provides high-level functions to insert, remove and modify lines, along with text input handlers and convenience function to delete words or characters.</p>"},{"location":"developer-guide/documents/#inserting-and-removing-text","title":"Inserting and removing text","text":"<p>To insert text at the current cursors' position, you can use <code>Doc:text_input()</code>. This function will replace selections and handle text overwriting. You can pass a selection / cursor index for the second parameter to only insert text in the specified cursor.</p> <p>For inserting text at a specified position, you can use <code>Doc:insert()</code>. This function takes in the initial position and a string, and inserts it into the Doc.</p> <p>To remove text from the Doc, call <code>Doc:remove()</code>. The function accepts the start and end position of the region of text to remove.</p> <p>These two functions has their low level counterpart, <code>Doc:raw_insert()</code> and <code>Doc:raw_remove()</code>. These function takes the undo stack and the time in seconds as extra arguments. They also don't call any event handlers related to Doc change.</p> <pre><code>-- insert text after all the selections\ndoc:text_input(\"hello world\")\n\n-- insert text after the 2nd selection\ndoc:text_input(\"hello world\", 2)\n\n-- insert text at the top of the doc\ndoc:insert(1, 1, \"hello world\")\n\n-- remove 2 characters from the first line\ndoc:remove(1, 1, 1, 3)\n</code></pre>"},{"location":"developer-guide/documents/#replacing-text","title":"Replacing text","text":"<p>To replace text within selections, you can call <code>Doc:replace()</code>. This function accepts a replace function, which accepts the original selection text and returns the replaced text, optionally followed by a result value. The result values for each replacement are stored in a table and returned by <code>Doc:replace()</code>. If no text is selected, the function will try to replace all text in the Doc.</p> <p>A lower-level version of the function is available as <code>Doc:replace_cursor()</code>, which replaces text within a region and inserts the result to the cursor at the specified index. The function returns the result value from the replace function.</p> <pre><code>-- add another dash for all lua comments\nlocal function magic(text)\n    return text:gsub(\"%-%-\", \"---\")\nend\n\n-- replace for the entire doc\ndoc:replace(magic)\n\n-- replace a specific selection\nfor idx, l1, c1, l2, c2 in doc:get_selections(true) do\n    if l1 ~= l2 and c1 ~= c2 then\n        if l1 == what_we_want and c1 == what_we_want then\n            doc:replace_cursor(idx, l1, c1, l2, c2, magic)\n        end\n    end\nend\n</code></pre>"},{"location":"developer-guide/documents/#convenience-functions","title":"Convenience functions","text":"<p><code>Doc:move_to()</code> and <code>Doc:move_to_cursor()</code> can be used to move the cursors to a specified position with similar arguments to <code>Doc:position_offset()</code>. <code>Doc:move_to_cursor()</code> accepts a cursor index as the first argument.</p> <p><code>Doc:select_to()</code> and <code>Doc:delete_to()</code> can be used and delete text with similar arguments to <code>Doc:position_offset()</code>. <code>Doc:select_to_cursor()</code> and <code>Doc:delete_to_cursor()</code> does the same thing but allows the user to specify a cursor or selection index to operate on.</p> <pre><code>local translate = require \"core.doc.translate\"\n\n-- move to the end of the next word\ndoc:move_to(translate.next_word_end)\n\n-- move all selections to word end\n-- this moves both the start and end positions of selections\nfor idx, _, _, _, _ in doc:get_selections() do\n    doc:move_to_cursor(idx, translate.next_word_end)\nend\n</code></pre>"},{"location":"developer-guide/documents/#saving","title":"Saving","text":"<p>To save a Doc, you can call <code>Doc:save()</code>.</p> <p>This function saves the Doc to a file with the name from <code>filename</code> or <code>self.filename</code> if <code>filename</code> is nil. If the Doc doesn't have a filename set, this function will set the filename for the Doc.</p> <pre><code>function Doc:save(filename?: string) end\n</code></pre>"},{"location":"developer-guide/documents/#events","title":"Events","text":"<p>Doc provides some functions that could be overridden for certain events, such as <code>Doc:on_text_change()</code> and <code>Doc:on_close()</code>.</p> <pre><code>local on_text_change = Doc.on_text_change\nfunction Doc:on_text_change(type)\n    if type == \"insert\" then\n        -- text is inserted\n    elseif type == \"remove\" then\n        -- text is removed\n    elseif type == \"undo\" then\n        -- undo\n    end\n    on_text_change(type)\nend\n\nlocal on_close = Doc.on_close\nfunction Doc:on_close()\n    on_close()\nend\n</code></pre>"},{"location":"developer-guide/interacting-with-the-os/","title":"Interacting with the OS","text":"<p>This is where Lite XL's Lua code interact with its underlying C engine.</p>"},{"location":"developer-guide/interacting-with-the-os/#using-the-system-api","title":"Using the System API","text":"<p>There are many functions that belong to this API; not all are necessary for plugin development. As such, we'll ignore them here and only document the useful ones.</p>"},{"location":"developer-guide/interacting-with-the-os/#clipboard","title":"Clipboard","text":"<p><code>system.set_clipboard()</code> sets the clipboard content, while <code>system.get_clipboard()</code> retrieves the clipboard content.</p> <p>The functions do not support rich content such as images and files.</p> <pre><code>function system.set_clipboard(text: string): () end\nfunction system.get_clipboard(text: string): string end\n</code></pre> <p>Examples:</p> <pre><code>system.set_clipboard(\"wow magic\")\n-- prints:\n-- wow magic\nprint(system.get_clipboard(\"wow magic\"))\n</code></pre>"},{"location":"developer-guide/interacting-with-the-os/#file-directory-operations","title":"File / Directory operations","text":"<p>These functions deal with files, directories and paths.</p> <pre><code>-- Returns a list of files and directories in a directory.\nfunction system.list_dir(path: string): {string}, string end\n-- Creates a new directory.\nfunction system.mkdir(path: string): boolean, string end\n-- Removes a directory.\nfunction system.rmdir(path: string): boolean string end\n-- Changes the current working directory (equivalent to the `cd` command)\nfunction system.chdir(path: string): () end\n-- Resolves the input path (removing all '.' and '..') into an absolute path.\nfunction system.absolute_path(path: string): () end\n\n-- Types of paths\nlocal enum FileType\n  \"file\"\n  \"dir\"\nend\n\n-- The information for a path\nlocal record FileInfo\n  modified: number\n  size: number\n  type: FileType\n  symlink: boolean\nend\n\n-- Returns information for a file or a directory.\nfunction system.get_file_info(path: string): FileInfo, string end\n</code></pre> <p><code>system.get_file_info()</code> returns a table with the following properties:</p> <ul> <li><code>modified</code>: Modification time in seconds (UNIX timestamp).</li> <li><code>size</code>: Size of the file in bytes.</li> <li><code>type</code>: Type of the path (Can be <code>file</code> or <code>dir</code>).</li> <li><code>symlink</code>: The directory is a symlink (Only set on Linux and on directories).</li> </ul> <p>All the functions listed above except <code>system.chdir()</code> will return <code>nil</code> followed by an error message when an error occurred. <code>system.chdir()</code> will throw an error if an error occurred.</p> <p>Examples:</p> <pre><code>-- DO NOT RUN THIS CODE!\n-- the code and its outputs are purely for demonstration only,\n-- and will not reflect your actual usage.\nlocal dir = \"../lite-xl\"\nlocal dir_resolved = system.absolute_path(dir)\n-- prints:\n-- /home/user/gh/lite-xl\nprint(dir_resolved)\n\n-- prints:\n-- .git =&gt; dir\n-- docs =&gt; dir\n-- .editorconfig =&gt; file\n-- LICENSE =&gt; file\n-- ...\n-- lite-xl =&gt; file\nfor i, d in ipairs(system.list_dir(dir_resolved)) do\n  local info = system.get_file_info(dir_resolved .. \"/\" .. d)\n  print(d .. \" =&gt; \" .. info.type)\nend\n\n-- create some directories\n-- this will not work because system.mkdir() doesn't create directories\n-- recursively, just like `mkdir` command without the `-p` option.\n-- prints:\n-- false   No such file or directory\nprint(system.mkdir(dir_resolved .. \"/1/2\"))\n\n-- these will work\n-- prints:\n-- true\nprint(system.mkdir(dir_resolved .. \"/1\"))\n-- prints:\n-- true\nprint(system.mkdir(dir_resolved .. \"/1/2\"))\n\n-- system.rmdir() does not support removing non-empty dirs, so\n-- this will not work and print an error\n-- prints:\n-- false   Directory not empty\nprint(system.rmdir(dir_resolved .. \"/1\"))\n\n-- instead, you should try to remove them recursively, making sure that each\n-- directory is empty\n-- prints:\n-- true\nprint(system.rmdir(dir_resolved .. \"/1/2\"))\n-- prints:\n-- true\nprint(system.rmdir(dir_resolved .. \"/1\"))\n</code></pre>"},{"location":"developer-guide/interacting-with-the-os/#timing","title":"Timing","text":"<p><code>system.get_time()</code> returns time in seconds since Lite XL started. It is a high-precision alternative to <code>os.time()</code>.</p> <pre><code>function system.get_time(): number end\n</code></pre> <p>Examples:</p> <pre><code>-- prints:\n-- 30148.079763237\nprint(system.get_time())\n</code></pre>"},{"location":"developer-guide/interacting-with-the-os/#window-manipulation","title":"Window manipulation","text":"<p>These functions deal with Lite XL window.</p> <pre><code>-- Sets the window opacity from 0 to 1.\nfunction system.set_window_opacity(opacity: number): boolean end\n-- Sets the window title.\nfunction system.set_window_title(title: string): () end\n\nlocal enum WindowMode\n  \"normal\"\n  \"maximized\"\n  \"minimized\"\n  \"fullscreen\"\nend\n\n-- Sets the window mode.\nfunction system.set_window_mode(mode: WindowMode): () end\n\n-- Enables/disables window borders (decoration).\nfunction system.set_window_bordered(enable: boolean): () end\n-- Sets the window hit test region.\nfunction system.set_window_hit_test(height?: number,\n                                    control_width?: number,\n                                    resize_border?: number): ()\nend\n-- Gets the window dimension and position.\nfunction system.get_window_size(): {number, number, number, number} end\n-- Sets the window dimension and position.\nfunction system.set_window_size(width:  number,\n                                height: number,\n                                x:      number,\n                                y:      number): ()\nend\n-- Checks whether windows has input focus.\nfunction system.window_has_focus(): boolean end\n-- Shows a message box with an error message.\nfunction system.show_fatal_error(title: string, msg: string): () end\n</code></pre> <p>The <code>height</code> parameter in <code>system.set_window_hit_test()</code> refers to the height of the top decoration. Users can drag this part of the window to move it. <code>control_width</code> specifies the width of various window controls (minimize, maximize and close) buttons in the top right corner of the window. <code>resize_border</code> specifies the width of a \"border region\" where users can drag the window to resize it. This value does not overlap with the <code>height</code> parameter.</p> <p><code>system.get_window_size()</code> returns the width, height, x-coordinate and y-coordinate of the window respectively.</p> <p><code>system.set_window_opacity()</code> will return <code>false</code> if the operation failed. Otherwise, it returns <code>true</code>.</p>"},{"location":"developer-guide/interacting-with-the-os/#miscellaneous","title":"Miscellaneous","text":"<p><code>system.exec()</code> runs a command in the background. It is useful if you just want to run a program and doesn't care about its output and exit code. If you want more features, consider using the Process API.</p> <p><code>system.fuzzy_match()</code> generates a score for sorting text based on relevance.</p> <pre><code>function system.exec(command: string): () end\nfunction system.fuzzy_match(haystack: string,\n                            needle:   string,\n                            file:     boolean): number\nend\n</code></pre> <p><code>system.exec()</code> accepts a string containing a command to run. This command will be run as <code>system(\"&lt;command&gt; &amp;\")</code> on POSIX platforms and <code>cmd /c \"&lt;command&gt;\"</code> on Windows, so make sure that the command is escaped properly.</p> <p><code>system.fuzzy_match()</code> takes in a <code>haystack</code> (a possible match) and a <code>needle</code> (the string to search) to generate a similarity score. If the score is 1, both strings are identical. When the third argument is <code>true</code>, the matching will be done backwards as this is more suitable for matching paths.</p>"},{"location":"developer-guide/introduction/","title":"Introduction","text":"<p>Lite XL has little functionalities without plugins \u2014 anything that can be implemented as plugins can and will be implemented as one.</p> <p>Lite XL is mostly written in Lua 5.4. If you want to write plugins, you need to know how to write Lua. There are various resources such as the Lua 5.4 Reference Manual, Programming in Lua, Learn Lua in 15 Minutes, Lua Tutorial at TutorialsPoint and Lua Tutorial at lua-users.org.</p> <p>You will also need general programming knowledge and some experience with object-oriented programming.</p> <p>Some of these tutorials target older versions of Lua and may be less relevant.</p> <p>The latest version of Lite XL uses Lua 5.4.6, while older versions uses Lua 5.2 and LuaJIT. These versions have breaking changes that has to be accounted when following the tutorials.</p>"},{"location":"developer-guide/introduction/#overview","title":"Overview","text":"<p>Lite XL is a fork of lite. As such, a lot of concepts used in lite is inherited in Lite XL. Lite: An Implementation Overview is an excellent article that explains many concepts about lite.</p>"},{"location":"developer-guide/introduction/#types-of-plugins","title":"Types of plugins","text":"<p>There are a few types of plugins. Syntaxes and colors are considered as subset of plugins. These subsets of plugins only interact with the syntax highlighter and the <code>style</code> table respectively.</p>"},{"location":"developer-guide/introduction/#interactive-debugging","title":"Interactive debugging","text":"<p>Other than using GDB to debug the C part of Lite XL, you can also debug the Lua part with lite-debugger. Follow this guide to learn how it works.</p>"},{"location":"developer-guide/managing-keyboard-shortcuts/","title":"Managing Keyboard Shortcuts","text":"<p>Mouse clicks, wheel and keyboard events are handled by <code>core.keymap</code> before it was passed to other parts of the editor. The keymap holds the state of various keys, including the modifiers (<code>keymap.modkeys</code>) and runs a command when it's appropriate. The keymap holds a map of key combinations to commands (<code>keymap.map</code>) and a map of commands to key combinations (<code>keymap.reverse_map</code>).</p>"},{"location":"developer-guide/managing-keyboard-shortcuts/#keyboard-shortcut-format","title":"Keyboard shortcut format","text":"<p>The string is split into parts delimited by <code>+</code> and each part of the split string is treated as a key. For the list of valid keys, check out SDL's documentation (the \"Key Name\" column).</p> <p>For mouse buttons, the format is as follows:</p> <p><code>[nclicks][type]click</code></p> <p><code>nclicks</code> is the number of clicks and defaults to 1 when not specified. <code>type</code> is optional and can be one of <code>l</code>, <code>r</code>, <code>m</code>, <code>x</code> and <code>y</code>. These letters correspond to left, right middle, mouse 4 and mouse 5. By default, <code>type</code> is set to <code>l</code>.</p> <p>Note</p> <p>Lite XL does not support consecutive keystrokes, such as <code>ctrl+k ctrl+b</code>.</p> <p>Examples:</p> <pre><code>-- bind core:find-command to ctrl+k\nkeymap.add { [\"ctrl+k\"] = \"core:find-command\" }\n\n-- bind core:find-command to clicking middle mouse\nkeymap.add { [\"mclick\"] = \"core:find-command\" }\n\n-- bind core:find-command to double clicking right mouse\nkeymap.add { [\"2mclick\"] = \"core:find-command\" }\n</code></pre>"},{"location":"developer-guide/managing-keyboard-shortcuts/#adding-keyboard-shortcuts","title":"Adding Keyboard Shortcuts","text":"<p>Ways to add keyboard shortcuts were already discussed in the user guide. To add keyboard shortcuts programmatically, use <code>keymap.add()</code>.</p> <pre><code>-- a composite type for commands\nlocal type Commands = string | {string}\n\nfunction keymap.add(map: {string: Commands}, overwrite: boolean): () end\n</code></pre> <p><code>keymap.add()</code> takes in a table of keyboard shortcuts and the commands for each keyboard shortcut. If the second parameter <code>overwrite</code> is true, then the commands will be replaced instead of appended.</p> <p>Example:</p> <pre><code>local keymap = require \"core.keymap\"\n\n-- bind alt + ijkl to move the cursor\nkeymap.add {\n  [\"alt+j\"] = \"doc:move-to-previous-char\",\n  [\"alt+l\"] = \"doc:move-to-next-char\",\n  [\"alt+i\"] = \"doc:move-to-previous-line\",\n  [\"alt+k\"] = \"doc:move-to-next-line\",\n}\n\n-- you can also bind a keybind to execute multiple actions\nkeymap.add {\n  [\"ctrl+c\"] = [\"doc:move-to-next-line\", \"doc:move-to-next-word\"]\n}\n\n-- you can also overwrite current keybind\n-- override up for down\nkeymap.add({\n  [\"down\"] = \"doc:move-to-previous-line\",\n  [\"up\"] = \"doc:move-to-next-line\",\n}, true)\n</code></pre>"},{"location":"developer-guide/managing-keyboard-shortcuts/#removing-a-keyboard-shortcut","title":"Removing a Keyboard Shortcut","text":"<p>To remove a keyboard shortcut, you can use <code>keymap.unbind()</code>.</p> <pre><code>function keymap.unbind(shortcut: string, command?: string): () end\n</code></pre> <p>The function accepts a keyboard shortcut and optionally a command to unbind. If a command is specified, the function will unbind that command from the key. Otherwise, it will unbind all commands from the shortcut.</p>"},{"location":"developer-guide/managing-keyboard-shortcuts/#getting-keyboard-shortcuts","title":"Getting Keyboard Shortcuts","text":"<p>To get all the keyboard shortcuts associated with a command, use <code>keymap.get_binding()</code> or <code>keymap.get_bindings()</code>.</p> <pre><code>function keymap.get_binding(cmd: string): string... end\n\nfunction keymap.get_bindings(cmd: string): {string} end\n</code></pre> <p>Both functions accept a command and returns the keyboard shortcuts associated to it. However, <code>keymap.get_bindings()</code> returns a table instead of a list of values.</p>"},{"location":"developer-guide/managing-keyboard-shortcuts/#overriding-the-keymap","title":"Overriding the Keymap","text":"<p>If your plugin need to override the keymap for extra functionality (e.g. redirecting keyboard shortcuts to a terminal), you can override <code>keymap.on_key_pressed()</code>, <code>keymap.on_mouse_wheel()</code>, <code>keymap.on_mouse_pressed()</code> and <code>keymap.on_key_released()</code>.</p> <pre><code>function keymap.on_key_pressed(key: string, ...: any): boolean end\n\nfunction keymap.on_mouse_wheel(delta_y: number,\n                                delta_x: number,\n                                ...: any): boolean end\n\nfunction keymap.on_mouse_pressed(button: string,\n                                  x: number,\n                                  y: number,\n                                  clicks: number): boolean end\n\nfunction keymap.on_key_released(key: string): () end\n</code></pre> <p><code>keymap.on_key_pressed()</code> accepts the key that is being pressed. The other values are reserved for internal usage and should be passed as-is.</p> <p><code>keymap.on_mouse_wheel()</code> accepts the X and Y delta \u2014 the number of \"steps\" scrolled on the mouse wheel. Other values are reserved for internal usage and should be passed as-is.</p> <p><code>keymap.on_mouse_pressed()</code> accepts the type of button being pressed, the coordinates where the button is pressed and the number of consecutive clicks.</p> <p><code>keymap.on_key_released()</code> accepts the key that is released.</p> <p><code>keymap.on_key_pressed()</code>, <code>keymap.on_mouse_wheel()</code> and <code>keymap.on_mouse_pressed()</code> returns a boolean that signals if the event is being handled. If the function returns true, then the event is considered handled and will not be propagated further. You must handle this condition if you decide to override any of these functions.</p> Since v2.1.0, text composition events (IME) should be taken into consideration when handling key events. <p>In recent versions of Lite XL, text composition/input events has been added to support IMEs. When text input is enabled, you may receive a key down event and a text input event. You need to consider how to handle these new events too.</p> <p>Example:</p> <pre><code>local keymap = require \"core.keymap\"\n\n-- a simple function that logs your keypresses\nlocal keymap_on_key_pressed = keymap.on_key_pressed\nfunction keymap.on_key_pressed(key, ...)\n  local handled = keymap_on_key_pressed(self, key, ...)\n  print(key, \"Pressed!\")\nend\n\nlocal ime = require \"core.ime\"\n\n-- to handle IME text composition events, you need to\n-- check the ime.editing value.\n-- If this value is true, text is being composited.\n-- You might want to ignore the keypresses.\nfunction keymap.on_key_pressed(key, ...)\n  -- on Linux this behavior is not observed so it can\n  -- be skipped\n  if PLATFORM ~= \"Linux\" and ime.editing then return false end\n  local handled = keymap_on_key_pressed(self, key, ...)\n  print(key, \"Pressed!\")\nend\n</code></pre>"},{"location":"developer-guide/simple-plugin/","title":"Simple Plugin","text":""},{"location":"developer-guide/simple-plugin/#what-is-simple","title":"What is Simple?","text":"<p>Simple is a very basic plugin written with the intention of introducing developers who are new to Lite XL to the process of writing plugins for the editor.</p>"},{"location":"developer-guide/simple-plugin/#what-does-the-plugin-do","title":"What does the plugin do?","text":"<p>The plugin displays a message (that is taken as input from the user) in the top right corner of the editor window. It also allows the user to toggle the visibility of the message.</p>"},{"location":"developer-guide/simple-plugin/#i-cant-write-lua","title":"I can't write Lua!","text":"<p>If you come from other programming languages, take a look at Lua cheat sheet. If you're new to programming, you can read this.</p>"},{"location":"developer-guide/simple-plugin/#format-of-the-tutorial","title":"Format of the tutorial","text":"<p>The code contains comments detailing what most (if not all) of the code in the file does.</p>"},{"location":"developer-guide/simple-plugin/#the-code","title":"The code","text":"<pre><code>-- mod-version:3\n\n-- you MUST put mod-version:x on the first line of your plugin\n-- mod-version usually maps to lite-xl releases (eg. mod-version: 2 == lite-xl 2.0)\n-- lite-xl won't load the plugin if the mod-version mismatches\n\n-----------------------------------------------------------------------\n-- NAME       : Simple\n-- DESCRIPTION: A simple guide on how to make your first Lite XL plugin\n-- AUTHOR     : Ashwin Godbole (aelobdog)\n-- GOALS      : To render some text inside the editor\n-----------------------------------------------------------------------\n-- Disclaimer :\n-- I am not a lua developer, and my knowledge about writing plugins for\n-- Lite XL is very limited. This file serves the purpose of helping the\n-- reader get started with plugin development for Lite XL, and therefore\n-- demonstrates only some very basic features. For more complex plugin\n-- development, be sure to check out the source code of some other\n-- plugins after going through this file.\n-----------------------------------------------------------------------\n-- Before we start writing any code for the plugin, we must import the\n-- required modules from the \"core\" package.\n\n-- the \"core\" module\nlocal core = require \"core\"\n\n-- the \"command\" module will help us register commands for our plugin.\nlocal command = require \"core.command\"\n\n-- the \"style\" module will allow us to use styling options\nlocal style = require \"core.style\"\n\n-- the \"config\" module will be used to store certain things like colors\n-- and functions\nlocal config = require \"core.config\"\n\n-- the \"keymap\" module will allow us to set keybindings for our commands\nlocal keymap = require \"core.keymap\"\n\n-- since we want to modify RootView, we'll need to require it first\nlocal RootView = require \"core.rootview\"\n\n-----------------------------------------------------------------------\n-- per-plugin config must stay in config.plugins.(plugin name)\nconfig.plugins.simple = {}\n\n-- colors are just three or four comma separated values (RGBA) (range 0 - 255)\n-- put inside of '{ }'. We will add our color to the config module.\nconfig.plugins.simple.text_color = {200, 140, 220} -- or use `{ common.color \"#C88CDC\" }`\n-----------------------------------------------------------------------\n-- Let's create a function to calculate the coordinates of our text.\n-- While we're at it, let's add our function to the `config` module.\n-- We'll take the message we want to display as the argument to the\n-- function to determine the x and y coordinates of the text.\n\nfunction config.plugins.simple.get_text_coordinates(message)\n   -- For this plugin, we want to display the text on the top right\n   -- corner of the screen. For this, we need to know the editor's width\n   -- and height.\n\n   -- The current font's size can be obtained from the \"style\" module.\n   -- The editor's dimensions can be obtained by\n   --   1. WIDTH  : core.root_view.size.x\n   --   2. HEIGHT : core.root_view.size.y\n\n   local message_width = style.code_font:get_width(message..\" \")\n   local font_height = style.code_font:get_size()\n   local x = core.root_view.size.x - message_width\n   local y = font_height / 2\n\n   return x, y\nend\n-----------------------------------------------------------------------\n-- Let's now get to actually drawing the text inside the editor.\n-- In order to \"inject\" our own code to draw text,\n-- we'll need to save the original draw function\n-- We'll save `RootView.draw` to a variable we call `parent_draw`\n\nlocal parent_draw = RootView.draw\n\n-- Now let's overload the original definition of `draw` in RootView\n-- by redefining the function.\n\nfunction RootView:draw()\n   -- We call the parent's function to keep the editor functional...\n   -- obviously we must still draw all the other stuff !\n   -- So we call the `parent_draw` function before doing anything else.\n   parent_draw(self)\n\n   -- we'll add an option to toggle the message on and off. let's use a\n   -- boolean variable to keep track of whether we want to display the\n   -- message or not.\n   if config.plugins.simple.show_my_message then\n      -- We'll be getting the message to display as input from the user\n      -- later. We'll store that user input in `config.plugins.simple.hw_message`.\n      -- (NOTE: this variable does not come in-built in lite-xl;\n      --        it is a variable that we will define later.)\n\n      -- let's store the value of config.plugins.simple.hw_message in a local variable\n      -- `message` in case config.plugins.simple.hw_message we set the message to\n      -- \"message not set yet!\"\n      local message\n\n      if config.plugins.simple.hw_message then\n          message = config.plugins.simple.hw_message\n      else\n          message = \"Message not set yet !\"\n      end\n\n      -- let's get the coordinates for our text\n      local x, y = config.plugins.simple.get_text_coordinates(message)\n\n      -- let's finally draw the text to the window !\n      -- the draw_text function from `renderer` is an important function\n      -- as it is used to display any and all text inside of the editor\n      -- window\n      renderer.draw_text(style.code_font, message, x, y, config.plugins.simple.text_color)\n   end\nend\n-----------------------------------------------------------------------\n-- Let's allow the user to turn the message on and off\n-- we'll write a function to flip our \"show\" boolean variable.\n\nlocal function toggle_helloworld()\n   config.plugins.simple.show_my_message = not config.plugins.simple.show_my_message\nend\n-----------------------------------------------------------------------\n-- Finally, let's add the toggle function to the command list so that\n-- we can call it from the C-S-p command panel. Let's add one command\n-- to toggle the visibility of the message on and off and one to get\n-- the user's message and then display it.\n\ncommand.add(nil, {\n   -- Toggle the visibility of the message\n   [\"simple:toggle\"] = toggle_helloworld,\n\n   -- Set and show the message\n   -- This is the way to get user input through the command bar.\n   -- `core.command_view:enter` takes 2 arguments:\n   --    * the prompt to display before taking input\n   --    * a function that takes the \"input\" as its argument\n   -- (NOTE: here the variable we are reading input into is `text`)\n   [\"simple:setshow\"] = function()\n      core.command_view:enter(\"Test to display\", {\n         submit = function(text)\n            config.plugins.simple.hw_message = text\n            config.plugins.simple.show_my_message = true\n         end\n      })\n   end\n})\n-----------------------------------------------------------------------\n-- Just for fun, let's assign our commands their own keybindings.\n-- Here, we assign the keybinding the same string(its name) as the one\n-- that we set while creating the command\nkeymap.add {\n   [\"alt+s\"] = \"simple:setshow\",\n   [\"alt+t\"] = \"simple:toggle\",\n}\n</code></pre>"},{"location":"developer-guide/using-regular-expressions/","title":"Using Regular Expressions","text":"<p>This API provides PCRE (Perl-Compatible Regular Expressions) and is written in C and Lua. The API bears some similarity to Lua's pattern library with some differences.</p>"},{"location":"developer-guide/using-regular-expressions/#example-matching-capture-groups-with-a-regular-expression","title":"Example: matching capture groups with a regular expression","text":"<pre><code>local s = \"hello world hello world\"\nfor hello, world in regex.gmatch(\"(hello)\\\\s+(world)\", s) do\n    print(hello .. \" \" .. world)\nend\n</code></pre>"},{"location":"developer-guide/using-regular-expressions/#example-replacing-words-with-a-regular-expression","title":"Example: replacing words with a regular expression","text":"<pre><code>local s = \"hello world John!\"\nprint(regex.gsub(\"hello world (.+)!\", s, \"Hello world $1 Doe!\"))\n</code></pre>"},{"location":"developer-guide/using-regular-expressions/#using-the-regex-api","title":"Using the Regex API","text":"<p>Most Regex API functions accept a <code>Regex</code> object or a string to compile into a regex as their first argument. The only exception is <code>regex:cmatch()</code> which requires the first argument to be a <code>Regex</code> object.</p> <p>For more information regarding PCRE itself, please consult the documentation or a cheat sheet.</p>"},{"location":"developer-guide/using-regular-expressions/#creating-a-regex","title":"Creating a regex","text":"<p>Use <code>regex.compile()</code> to compile a regular expression. Compiling a regular expression is recommended if the user plans to use them frequently.</p> <pre><code>function regex.compile(pattern:  string,\n                        options?: string): Regex, string\nend\n</code></pre> <p>The first argument to the function is the regular expression to compile. The second argument to the function is a string containing one or more pattern modifiers.</p> <ul> <li><code>\"i\"</code> enables case-insensitive matching</li> <li><code>\"m\"</code> enables multi-line matching</li> <li><code>\"s\"</code> matches all characters with the dot (<code>.</code>) meta-character, including newlines.</li> </ul> <p>The function returns a compiled <code>Regex</code> object. If an error occurred, <code>nil</code> is returned along with an error message.</p> <p>Example:</p> <pre><code>local s = \"Hello world!\\nWow!\"\n\n-- simple regex\nlocal r = regex.compile \"([A-Z]+)(,+)\"\n-- prints:\n-- H       ello world!\nprint(r:match(s))\n\n-- case-insensitive matching\nlocal r = regex.compile(\"([A-Z]+)(,+)\", \"i\")\n-- prints:\n-- Hello    world!\nprint(r:match(s))\n\n-- match all characters with .\nlocal r = regex.compile(\"([A-Z]+)(,+)\", \"is\")\n-- prints:\n-- Hello    world!\n-- Wow!\nprint(r:match(s))\n</code></pre>"},{"location":"developer-guide/using-regular-expressions/#matching-text","title":"Matching text","text":"<p>The Regex API provides low-level matching functions (<code>regex:cmatch()</code>, <code>regex.find_offsets()</code>), and high-level matching functions (<code>regex.match()</code>,<code>regex.find()</code>, <code>regex.gmatch()</code>, <code>regex.gsub()</code>).</p> <pre><code>function regex:cmatch(subject: string,\n                      offset:  number,\n                      options: number): number...\nend\n\nfunction regex.find_offsets(pattern:  string | Regex,\n                            subject:  string,\n                            offset?:  number,\n                            options?: number): number...\nend\n\nlocal type Captures = number | string\n\nfunction regex.match(pattern:   string | Regex,\n                      subject:  string,\n                      offset?:  number,\n                      options?: number): Captures...\nend\n\nfunction regex.find(pattern: string | Regex,\n                    subject: string,\n                    offset?:  number,\n                    options?: number): Captures...\nend\n\n-- since v2.1.1\nfunction regex.gmatch(pattern: string | Regex,\n                      subject: string,\n                      offset?:  number,\n                      options?: number): function(): string\nend\n</code></pre> <p>The first argument to <code>regex:cmatch()</code> is the subject string. The second argument is an offset in the subject string to indicate when to start matching. The third argument is a number comprised of multiple match options OR-ed together. These options are:</p> <ul> <li><code>regex.ANCHORED</code>: Only matches the start of the input; similar to the <code>^</code> meta-character.</li> <li><code>regex.ENDANCHORED</code>: Only matches the end of the input; similar to the <code>$</code> meta-character.</li> <li><code>regex.NOTBOL</code>: Do not treat beginning of subject string as beginning of line.</li> <li><code>regex.NOTEOL</code>: Do not treat end of subject string as end of line.</li> <li><code>regex.NOTEMPTY</code>: Do not treat an empty subject string as a valid match.</li> <li><code>regex.NOTEMPTY_ATSTART</code>: Do not treat empty string at the start of a subject string as a valid match.</li> </ul> <p><code>regex.find_offsets()</code> accepts the same arguments, but the first argument can be a compiled <code>Regex</code> object or a string while the second and third argument are optional.</p> <p>Both <code>regex:cmatch()</code> and <code>regex.find_offsets()</code> return pairs of numbers indicating the start and end indices of all the matches. The first pair of numbers is the indices of the whole match. If captures were specified in the regex, the rest of the numbers are pairs of start and end indices for each capture.</p> <p>If no matches were found, both functions return <code>nil</code>. Otherwise, if an error occurred, both functions throw an error.</p> <p>Warning</p> <p>Never use <code>regex:cmatch()</code> as its return values are off by 1. Instead, use <code>regex:find_offsets()</code> which have the correct behavior.</p> <p>Example:</p> <pre><code>local s = \"Apples, Oranges, Bananas\"\nlocal r = regex.compile(\"([A-Za-z]+),\\\\s*(.+)\")\n-- prints:\n-- 24\nprint(#s)\n-- prints:\n-- 1       25      1       7       9       25\nprint(r:cmatch(s))\n-- prints:\n-- 1       24      1       6       9       24\nprint(r:find_offsets(s))\n</code></pre> <p><code>regex.match()</code> and <code>regex.find()</code> are similar to Lua's <code>string.match()</code> and <code>string.find()</code>.</p> <p>The first argument is the compiled <code>Regex</code> or a string, while the second argument is the subject string to match. The third and fourth argument specify the offset of the string to start matching and match options. The third and fourth argument are optional.</p> <p><code>regex.match()</code> will return all captured strings. If no captures are specified in the regex, it will return the matched string. If a capture is empty, its offset will be returned.</p> <p><code>regex.find()</code> will return the start and end indices of the matched string, followed by the captured strings if any. If a capture is empty, its offset will be returned.</p> <p>Both functions return <code>nil</code> if no match was found.</p> <p>Note</p> <p>There are no functions that return the start and end indices of captured strings. Use <code>regex.find_offsets()</code> for that.</p> <p>Example:</p> <pre><code>local s = \"Apples, Oranges, Bananas\"\n-- prints:\n-- Apples    Oranges, Bananas\nprint(regex.match(\"([A-Za-z]+),\\\\s*(.+)\", s))\n-- prints:\n-- 1    24    Apples    Oranges, Bananas\nprint(regex.find(\"([A-Za-z]+),\\\\s*(.+)\", s))\n</code></pre> <p><code>regex.gmatch()</code> returns an iterator that iterates through all captured groups, or the whole match if no captures are specified in the regex.</p> <p>It accepts the same arguments as <code>regex.find()</code> and <code>regex.match()</code>.</p> <p>Example:</p> <pre><code>local s = \"John doe, Jeanne Doe, Jane Doe\"\n-- will print:\n-- John - Doe\n-- Jeanne - Doe\n-- Jane - Doe\nfor first_name, last_name in regex.gmatch(\"([A-Za-z]+) ([A-Za-z]+)(,\\\\s*)?\", s) do\n  print(first_name .. \" - \" .. last_name)\nend\n\n-- will print:\n-- John\n-- doe\n-- Jeanne\n-- Doe\n-- Jane\n-- Doe\nfor name in regex.gmatch(\"\\\\w+\", s) do\n  print(name)\nend\n</code></pre>"},{"location":"developer-guide/using-regular-expressions/#string-substitution","title":"String substitution","text":"<p><code>regex.gsub()</code> can be used to perform simple string substitution.</p> <pre><code>function regex.gsub(pattern:     string | Regex,\n                    subject:     string,\n                    replacement: string,\n                    limit?:      number): string, number\nend\n</code></pre> <p>The first argument is the <code>Regex</code> object or a string, followed by the subject string. The third argument is the replacement string and the last is the maximum number of replacements to make.</p> <p>The function returns the subject string with matches replaced with the replacement string, followed by the number of replacements made.</p> <p>If an error occurred, the function throws an error.</p>"},{"location":"developer-guide/using-regular-expressions/#replacement-string","title":"Replacement string","text":"<p>The replacement string supports PCRE2 extended substitution syntax.</p> <p>To use named and unnamed capture groups with <code>$n</code> or <code>${n}</code> where <code>n</code> is the group number or name. The extended substitution syntax also supports two extra substitutions:</p> <ul> <li>The form <code>${n:-default}</code> will use <code>default</code> if <code>n</code> is unavailable.</li> <li>The form <code>${n:+iftrue:iffalse}</code> will use <code>iftrue</code> if <code>n</code> is available, otherwise it will use <code>iffalse</code>.</li> </ul> <p>To insert a literal dollar sign (<code>$</code>), use <code>$$</code>.</p> <p>Other than that, <code>\\U</code> and <code>\\L</code> can be used to toggle uppercase or lowercase, while <code>\\u</code> and <code>\\l</code> causes the next character to be in uppercase or lowercase.</p> <p>Example:</p> <pre><code>local s = \"John Doe, Jane Doe, Peter Doe\"\nlocal r = regex.compile \"(\\\\w+)\"\n\n-- prints:\n-- No No, No No, No No     6\nprint(r:gsub(s, \"No\"))\n-- prints:\n-- $John $doe, $Jane $Doe, $Peter $Doe     6\nprint(r:gsub(s, \"($1)\"))\n-- prints:\n-- john doe, jane doe, peter doe   6\nprint(r:gsub(s, \"\\\\l${1}\"))\n-- prints:\n-- Matched =&gt; John Matched =&gt; doe, Matched =&gt; Jane Matched =&gt; Doe, Matched =&gt; Peter Matched =&gt; Doe 6\nprint(r:gsub(s, \"${1:+Matched =&gt; $1:No match.}\"))\n</code></pre>"},{"location":"developer-guide/views/","title":"Views","text":"<p>Lite XL has the concept of Views and Nodes. Views in Lite XL is organized into binary tree, with each leaf node containing one or more Views. A branch can either split vertically or horizontally.</p> <p>A View is a UI component used to display content to the end user. As such, a View contains methods for event handling, state management and rendering.</p>"},{"location":"developer-guide/views/#creation","title":"Creation","text":"<p>A View can be created by extending the <code>View</code> class. The <code>View</code> class contains many important states and provides convenience methods for handling events.</p> <p>After that, you can create instances of Views and add them to a Node.</p> <p>For example, we'll create a View called <code>HelloView</code>.</p> <pre><code>-- mod-version:3\nlocal core = require \"core\"\nlocal command = require \"core.command\"\nlocal common = require \"core.common\"\nlocal style = require \"core.style\"\n\nlocal View = require \"core.view\"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we'll call View's constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- This can be \"session\" or \"application\"\n  -- If you specify \"application\", then the View will\n  -- not be closed when the user performs \"root:close-all\".\n  -- The user must explicitly close this View.\n  self.context = \"session\"\n  self.caption = \"Hello world!\"\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return \"Hello!\"\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  [\"hello:hello\"] = function()\n    -- We'll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n</code></pre> <p>Currently, this plugin will do nothing. You won't see anything because the View doesn't have a draw function.</p>"},{"location":"developer-guide/views/#size-position-and-scrolling","title":"Size, position and scrolling","text":"<p>A View can be thought of as a stencil on canvas. Everything drawn within the View dimension will be shown to the user, while everything drawn outside the View are discarded. This ties into how Lite XL handles scrolling \u2014 the canvas is moved around instead of the stencil.</p> <p>The size of a View (the stencil) is stored in <code>View.size.x</code> and <code>View.size.y</code>. These are the size of the stencil following our analogy. The size of the canvas is computed by calling <code>View:get_scrollable_size()</code> and <code>View:get_h_scrollable_size()</code>. These methods can return a value larger than the View size to enable scrolling or very huge numbers that represents an infinitely scrollable View.</p> <p>The position of the View relative to the window is stored in <code>View.position</code>. Following our analogy, these values represent where to place the stencil. In reality, these values are rarely used directly as values returned by <code>View:get_content_offset()</code> is more useful.</p> <p>If a View is scrollable, you should set <code>View.scrollable</code> to <code>true</code> and override <code>View:get_scrollable_size()</code> and <code>View:get_h_scrollable_size()</code>. You should also call <code>View:draw_scrollbar()</code> in your draw method to render Lite XL's scrollbar for convenience.</p> <p>When a View is scrollable, <code>View:get_content_offset()</code> can be used to determine where to start drawing. This method returns starting X and Y coordinates, which may be negative to represent hidden content above the View; or larger View size to represent hidden content after the View.</p> <p>The scroll state of the View is stored in <code>View.scroll</code>. This table contains the X and Y offset when the view is scrolled. To simulate scrolling, you can change the value of <code>View.scroll.to.x</code> or <code>View.scroll.to.y</code>. A positive value will scroll right / down while a negative value scrolls left / up. Alternatively, you may change <code>View.scroll.x</code> or <code>View.scroll.y</code> directly.</p> <p>In our example, we'll implement horizontal and vertical scrolling. The surface size is double our View size.</p> <pre><code>-- mod-version:3\nlocal core = require \"core\"\nlocal command = require \"core.command\"\nlocal common = require \"core.common\"\nlocal style = require \"core.style\"\n\nlocal View = require \"core.view\"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we'll call View's constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- set a caption that we'll use later\n  self.caption = \"Hello world!\"\n  self.scrollable = true\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return \"Hello!\"\nend\n\nfunction HelloView:get_scrollable_size()\n  -- the \"actual\" height of the View\n  return 2 * self.size.y\nend\n\nfunction HelloView:get_h_scrollable_size()\n  -- the \"actual\" width of the View\n  return 2 * self.size.x\nend\n\nfunction HelloView:draw()\n  -- You should call this to avoid overdrawing\n  -- previous content.\n  self:draw_background(style.background)\n  -- Draw the scrollbar\n  self:draw_scrollbar()\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  [\"hello:hello\"] = function()\n    -- We'll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n</code></pre> <p>You should end up with a View that is scrollable but has nothing in it. We're going to draw something in the next section.</p>"},{"location":"developer-guide/views/#rendering","title":"Rendering","text":"<p>The most important method of a view is <code>View:render()</code>.  This function is called when Lite XL wants to render something.</p> <p>As mentioned before, you can draw anywhere on the screen, but only the contents within the View is shown to the user. This is implemented by <code>Node.draw()</code> setting the clip rectangle to the dimensions of the View.</p> <p>In our example, we're going to draw the caption we've set in the constructor.</p> <pre><code>-- mod-version:3\nlocal core = require \"core\"\nlocal command = require \"core.command\"\nlocal common = require \"core.common\"\nlocal style = require \"core.style\"\n\nlocal View = require \"core.view\"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we'll call View's constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- set a caption that we'll use later\n  self.caption = \"Hello world!\"\n  self.scrollable = true\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return \"Hello!\"\nend\n\nfunction HelloView:get_scrollable_size()\n  -- the \"actual\" height of the View\n  return 2 * self.size.y\nend\n\nfunction HelloView:get_h_scrollable_size()\n  -- the \"actual\" width of the View\n  return 2 * self.size.x\nend\n\nfunction HelloView:draw()\n  -- You should call this to avoid overdrawing\n  -- previous content.\n  self:draw_background(style.background)\n  -- Get the top-left corner of the View\n  local x, y = self:get_content_offset()\n  -- We'll use view.size here so that looks centered\n  -- At the start.\n  local w, h = self.size.x, self.size.y\n  -- Draw the caption with common.draw_text().\n  -- This function provides some utilities such as alignment\n  -- over renderer.draw_text().\n  common.draw_text(style.font, style.text, self.caption, \"center\", x, y, w, h)\n  -- Draw the scrollbar\n  self:draw_scrollbar()\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  [\"hello:hello\"] = function()\n    -- We'll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n</code></pre> <p>You should end up with some text drawn in the center of the screen. In the next section, we'll make it more interesting.</p> <p>Never draw anything outside the render method.</p> <p>The render method is called after renderer.begin_frame().     Any draw calls before this function will be discarded.</p>"},{"location":"developer-guide/views/#events","title":"Events","text":"<p>Views have several methods to handle events. Events are usually propagated from the top (RootView) to the bottom. Event handlers are usually called <code>on_&lt;event_name&gt;</code> except <code>update</code>. You can override these methods to provide your own handler logic. Some events require you to return <code>true</code> to indicate that the event is handled and should not be propagated further.</p>"},{"location":"developer-guide/views/#periodic-updates","title":"Periodic updates","text":"<p>The <code>update</code> event is sent right before Lite XL redraws its UI. You can use this event to perform some state management among other things. The handler is called without arguments and should return nothing.</p> <p>In our example, let's extend <code>HelloView</code> by displaying the number of seconds elapsed since Lite XL started.</p> <pre><code>-- mod-version:3\nlocal core = require \"core\"\nlocal command = require \"core.command\"\nlocal common = require \"core.common\"\nlocal style = require \"core.style\"\n\nlocal View = require \"core.view\"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we'll call View's constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- set a caption that we'll use later\n  self.caption = \"Hello world!\"\n  self.scrollable = true\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return \"Hello!\"\nend\n\nfunction HelloView:get_scrollable_size()\n  -- the \"actual\" height of the View\n  return 2 * self.size.y\nend\n\nfunction HelloView:get_h_scrollable_size()\n  -- the \"actual\" width of the View\n  return 2 * self.size.x\nend\n\nfunction HelloView:update()\n  -- Update some important View states.\n  HelloView.super.update(self)\n  -- system.get_time() returns the number of seconds since Lite XL started.\n  self.caption = string.format(\"Time elapsed: %.2f\", system.get_time())\n  -- This tells Lite XL that we want to constantly redraw.\n  core.redraw = true\nend\n\nfunction HelloView:draw()\n  -- You should call this to avoid overdrawing\n  -- previous content.\n  self:draw_background(style.background)\n  -- Get the top-left corner of the View\n  local x, y = self:get_content_offset()\n  -- We'll use view.size here so that looks centered\n  -- At the start.\n  local w, h = self.size.x, self.size.y\n  -- Draw the caption with common.draw_text().\n  -- This function provides some utilities such as alignment\n  -- over renderer.draw_text().\n  common.draw_text(style.font, style.text, self.caption, \"center\", x, y, w, h)\n  -- Draw the scrollbar\n  self:draw_scrollbar()\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  [\"hello:hello\"] = function()\n    -- We'll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n</code></pre> <p>Try commenting out <code>core.redraw = true</code> in the update method.</p> <p>This will cause the timer to freeze as soon as there's no input. <code>View:update()</code> is only called when Lite XL wants to update the content; it will not be called when nothing is changed.</p>"},{"location":"developer-guide/views/#mouse","title":"Mouse","text":"<p>The keymap is the go-to way for handling mouse events with keystrokes. However, if you want to have more control over mouse events, you can override <code>View:on_mouse_moved()</code>, <code>View:on_mouse_pressed()</code>, <code>View:on_mouse_released()</code> and <code>View:on_mouse_wheel()</code>.</p> <pre><code>function View:on_mouse_moved(x: number,\n                              y: number,\n                              dx: number,\n                              dy: number): boolean end\n\nfunction View:on_mouse_pressed(button: MouseButton,\n                                x: number,\n                                y: number,\n                                clicks: number): boolean end\n\nfunction View:on_mouse_released(button: MouseButton,\n                                x: number,\n                                y: number): nil end\n\nfunction View:on_mouse_wheel(y: number, x: number): boolean end\n</code></pre> <p><code>View:on_mouse_moved()</code> accepts the X and Y coordinates of the mouse and the X and Y difference from the mouse's last position.</p> <p><code>View:on_mouse_pressed()</code> accepts the button pressed, the X and Y coordinates where the button is pressed and the number of clicks (from 1 to 3).</p> <p><code>View:on_mouse_released()</code> accepts the same arguments as <code>View:on_mouse_pressed()</code> except the number of clicks.</p> <p><code>View:on_mouse_wheel()</code> accepts the number of steps scrolled vertically and horizontally.</p> <p>All of these methods except <code>View:on_mouse_released()</code> returns a boolean indicating that the event is handled.</p> <p>In our example, we'll implement dragging the text around the view.</p> <pre><code>-- mod-version:3\nlocal core = require \"core\"\nlocal command = require \"core.command\"\nlocal common = require \"core.common\"\nlocal style = require \"core.style\"\n\nlocal View = require \"core.view\"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is the constructor for HelloView.\n  -- Here, we'll call View's constructor to initialize\n  -- some important states.\n  HelloView.super.new(self)\n  -- Set a caption that we'll use later\n  self:set_caption \"Hello world!\"\n  -- Position of the caption relative to View\n  self.caption_pos = { x = 0, y = 0 }\n  -- Position of cursor relative to caption\n  self.cursor_pos = { x = 0, y = 0 }\n  -- True if the user is dragging the caption\n  self.hold = false\n  self.scrollable = true\nend\n\nfunction HelloView:get_name()\n  -- Returns the display name of the View.\n  -- If tabs are enabled, this will be displayed as the tab title.\n  return \"Hello!\"\nend\n\nfunction HelloView:get_caption_size()\n  -- getter method for caption size\n  return self.caption_w, self.caption_h\nend\n\nfunction HelloView:set_caption(caption)\n  -- setter method for caption\n  self.caption_w = style.font:get_width(caption)\n  self.caption_h = style.font:get_height()\n  self.caption = caption\nend\n\nfunction HelloView:get_scrollable_size()\n  -- the \"actual\" height of the View\n  return 2 * self.size.y\nend\n\nfunction HelloView:get_h_scrollable_size()\n  -- the \"actual\" width of the View\n  return 2 * self.size.x\nend\n\nfunction HelloView:get_caption_bounding_box()\n  local x1, y1 = self:get_content_offset()\n  x1, y1 = x1 + self.caption_pos.x, y1 + self.caption_pos.y\n  local x2, y2 = x1 + self.caption_w, y1 + self.caption_h\n  return x1, y1, x2, y2\nend\n\nfunction HelloView:on_mouse_pressed(button, x, y, clicks)\n  -- Skip if the event is already handled\n  if HelloView.super.on_mouse_pressed(self, button, x, y, clicks) then return true end\n  local x1, y1, x2, y2 = self:get_caption_bounding_box()\n  if x &gt;= x1 and y &gt;= y1 and x &lt;= x2 and y &lt;= y2 then\n    -- Store cursor position relative to caption\n    self.cursor_pos.x, self.cursor_pos.y = x - x1, y - y1\n    self.hold = true\n    return true\n  end\n  return false\nend\n\nfunction HelloView:on_mouse_moved(x, y, dx, dy)\n  -- Skip if the event is already handled\n  if HelloView.super.on_mouse_moved(self, x, y, dx, dy) then return true end\n  if self.hold then\n    -- Normalize cursor position to top left corner of the caption\n    x, y = x - self.cursor_pos.x, y - self.cursor_pos.y\n    -- Get the position relative to View\n    local vx, vy = self:get_content_offset()\n    local vw, vh = self:get_h_scrollable_size() - self.caption_w, self:get_scrollable_size() - self.caption_h\n    self.caption_pos.x, self.caption_pos.y = common.clamp(x - vx, 0, vw), common.clamp(y - vy, 0, vh)\n  end\nend\n\nfunction HelloView:on_mouse_released(...)\n  HelloView.super.on_mouse_released(self, ...)\n  self.hold = false\nend\n\nfunction HelloView:update()\n  -- Update some important View states.\n  HelloView.super.update(self)\n  -- system.get_time() returns the number of seconds since Lite XL started.\n  self:set_caption(string.format(\"Time elapsed: %.2f\", system.get_time()))\n  -- This tells Lite XL that we want to constantly redraw.\n  core.redraw = true\nend\n\nfunction HelloView:draw()\n  -- You should call this to avoid overdrawing\n  -- previous content.\n  self:draw_background(style.background)\n  -- Get the top-left corner of the View\n  local x, y = self:get_content_offset()\n  -- Calculate the absolute position of the caption\n  x, y = x + self.caption_pos.x, y + self.caption_pos.y\n  -- We're using renderer.draw_text() as we don't need the alignment\n  -- goodies anymore.\n  -- Note the different order of arguments.\n  renderer.draw_text(style.font, self.caption, x, y, style.text)\n  -- Draw the scrollbar\n  self:draw_scrollbar()\nend\n\n-- Add a command to create a View.\ncommand.add(nil, {\n  [\"hello:hello\"] = function()\n    -- We'll get the current active node and add a view to it.\n    -- This will usually create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end\n})\n</code></pre> <p>We've used <code>on_mouse_pressed()</code>, <code>on_mouse_moved()</code> and <code>on_mouse_released()</code> method to track the cursor and draw the caption at the correct position. Note that <code>View:get_scrollable_size()</code> and <code>View:get_h_scrollable_size()</code> is used to compute the surface size. The text can now be dragged around.</p>"},{"location":"developer-guide/views/#text-input","title":"Text Input","text":"<p>To receive text input events, you must override <code>View:supports_text_input()</code>  and return <code>true</code>, then override <code>View:on_text_input()</code> and handle events.</p> <p>Additionally, if you wish to handle IME composition events as well, you can override <code>View:on_ime_text_editing()</code>. Most text editors uses this event to show a preview of the text being composed.</p> <pre><code>function View:on_text_input(text: string): nil end\nfunction View:on_ime_text_editing(text: string,\n                                  start: number,\n                                  length: number): nil end\n</code></pre> <p><code>View:on_text_input()</code> accepts a string containing the text entered and returns nothing.</p> <p><code>View:on_ime_text_editing()</code> accepts the text being composited, the start of current composition selection and the length of said selection. Generally, this event is emitted until the user finalizes the composition, then <code>on_text_input()</code> will be emitted followed by an empty <code>on_ime_text_editing</code> event.</p> <p>For instance, for inputting the text \"hello\" with a Pinyin IME:</p> <pre><code>on_ime_text_editing: \"\u548c\", 3, 0\non_ime_text_editing: \"\u5408\u7406\", 6, 0\non_ime_text_editing: \"hell\", 3, 0\non_ime_text_editing: \"hello\", 3, 0\non_text_input: \"hello\"\non_ime_text_editing: \"\", 0, 0\n</code></pre> <p>Let's implement rudimentary text input in our example.</p> <p>In our example, we'll add support for text input and IME composition.</p> <pre><code>--mod-version:3\nlocal core = require \"core\"\nlocal command = require \"core.command\"\nlocal common = require \"core.common\"\nlocal ime = require \"core.ime\"\nlocal keymap =require \"core.keymap\"\nlocal style = require \"core.style\"\n\nlocal View = require \"core.view\"\n\nlocal HelloView = View:extend()\nfunction HelloView:new()\n  -- This is HelloView's constructor.\n  -- You must call the super constructor to initialize important state data.\n  HelloView.super.new(self)\n  -- The position of the caption relative to the view\n  self.caption_pos = { x = 0, y = 0 }\n  -- The offset of the cursor from the top left corner of the caption\n  -- when it is held\n  self.cursor_offset = { x = 0, y = 0 }\n  -- The caption and its pixel width\n  self.caption = \"\"\n  self.caption_w = style.font:get_width(self.caption)\n  -- IME text composition state\n  self.composition = { text = \"\", start = 0, length = 0 }\n  self.hold = false\nend\n\nfunction HelloView:on_mouse_moved(px, py, dx, dy)\n  -- If the super method already handled the event, we shouldn't handle it.\n  -- This is important for scrollbar handling if view is scrollable.\n  if HelloView.super.on_mouse_moved(self, px, py, dx, dy) then return true end\n  -- If we're not holding down mouse we should ignore the event\n  if not self.hold then return end\n\n  -- Correct the mouse position to behave as if the cursor was placed on the\n  -- top-left corner of the caption.\n  -- Without this, the caption will \"jump\" towards the cursor.\n  px, py = px - self.cursor_offset.x, py - self.cursor_offset.y\n\n  -- Calculate the bounding rectangle of the Viee\n  local x1, y1 = self:get_content_offset()\n  -- Here, the bounding rectangle is shrunk by the size of the caption.\n  -- This prevents the caption from clipping out of the view.\n  local x2, y2 = self.size.x - self.caption_w, self.size.y - style.font:get_height()\n\n  -- Set the position of the caption relative to the view.\n  self.caption_pos.x, self.caption_pos.y = common.clamp(px - x1, 0, x2), common.clamp(py - y1, 0, y2)\n  return true\nend\n\nfunction HelloView:on_mouse_pressed(button, px, py, clicks)\n  -- If the super method handled the event we should skip our own handler.\n  if HelloView.super.on_mouse_pressed(self, button, px, py, clicks) then return true end\n\n  -- the bounding box of the caption\n  local x1, y1 = self:get_content_offset()\n  x1, y1 = x1 + self.caption_pos.x, y1 + self.caption_pos.y\n  local x2, y2 = x1 + self.caption_w, y1 + style.font:get_height()\n\n  if px &gt;= x1 and py &gt;= y1 and px &lt;= x2 and py &lt;= y2 then\n    -- Save the cursor position relative to the caption\n    self.cursor_offset.x, self.cursor_offset.y = px - x1, py - y1\n    self.hold = true\n  end\n  return true\nend\n\nfunction HelloView:on_mouse_released(...)\n  HelloView.super.on_mouse_released(self, ...)\n  self.hold = false\nend\n\nfunction HelloView:supports_text_input()\n  -- tell Lite XL that we support text input\n  return true\nend\n\nfunction HelloView:on_text_input(text)\n  -- Append text to the caption and recalculate the width\n  self.caption = self.caption .. text\n  self.caption_w = style.font:get_width(self.caption)\nend\n\nfunction HelloView:on_ime_text_editing(text, start, length)\n  -- Store composition state\n  self.composition = { text = text, start = start, length = length }\nend\n\nfunction HelloView:update()\n  -- You should do state management in this method.\n  -- If you override this method, you must call the super method.\n  HelloView.super.update(self)\n\n  if self.composition.text ~= \"\" then\n    -- We need to tell the system where to put the IME window.\n    -- Get the bounding box of the selected composition text\n    local ime_selection_text = self.composition.text:usub(self.composition.start, self.composition.length)\n    local ime_not_selected = self.composition.text:usub(1, self.composition.start - 1)\n    local x, y = self:get_content_offset()\n    x, y = x + self.caption_pos.x + style.font:get_width(ime_not_selected), y + self.caption_pos.y\n    -- Set the position of the IME window\n    ime.set_location(x, y, style.font:get_width(ime_selection_text), style.font:get_height())\n  end\nend\n\nfunction HelloView:draw()\n  -- In here, we did not call self.super.draw(self) because we're extending View.\n  -- View's draw() method does nothing.\n  -- Instead, we'll call self:draw_background() to draw the background.\n  -- If you don't call this, you'll overdraw previous content.\n  self:draw_background(style.background)\n  -- get the x and y offset of the View.\n  -- Since a view can be anywhere within a window, you must use this x and y\n  -- offset to ensure that you're drawing inside your View.\n  -- Otherwise, you will draw on other Views and the content can get obscured.\n  local x, y = self:get_content_offset()\n  x, y = x + self.caption_pos.x, y + self.caption_pos.y\n  -- Here, we switch to renderer.draw_text() because we don't need to align\n  -- the text anymore.\n  -- Note the different order of arguments.\n  x = renderer.draw_text(style.font,\n  self.caption,\n  x, y,\n  style.text)\n\n  local caret_pos = x\n  if self.composition.text ~= \"\" then\n    -- Draw the composition text\n    local xadvance = renderer.draw_text(style.font,\n                                        self.composition.text,\n                                        x, y,\n                                        style.text)\n    -- Draw an underline to indicate that this is a composition and not actual text.\n    renderer.draw_rect(x, y + style.font:get_height() - 2, xadvance - x, 2, style.accent)\n    -- The caret may appear in the middle of the composition.\n    -- The start parameter is the offset of the text where the selection starts, so we'll\n    -- use it to place the caret.\n    x = x + style.font:get_width(self.composition.text:usub(1, self.composition.start))\n  end\n  -- draw the caret.\n  renderer.draw_rect(x, y, 2, style.font:get_height(), style.caret)\nend\n\n\n-- add a command to create a View.\ncommand.add(nil, {\n  [\"hello:hello\"] = function()\n    -- we'll get the current active node and add a view to it.\n    -- it will create a new tab.\n    core.root_view:get_active_node():add_view(HelloView())\n  end,\n})\n\n-- add a command to delete caption text from the back\ncommand.add(HelloView, {\n  [\"hello:delete-char\"] = function()\n    -- we use string.usub to account for unicode multi-byte characters\n    core.active_view.caption = core.active_view.caption:usub(1, -2)\n  end\n})\n\n-- bind the delete command to backspace\nkeymap.add {\n  [\"backspace\"] = \"hello:delete-char\"\n}\n</code></pre> <p>There's a lot more to text editing than simply appending and removing text. This is just a simple example to acquaint you with how Lite XL handle events.</p>"},{"location":"developer-guide/views/#layout","title":"Layout","text":"<p>Lite XL manages UI layout in a binary tree. Each View is stored in a Node, and the Node is stored in a binary tree with RootView as the root node. RootView manages input and rendering events for all the Views.</p> <p>A Node is the basic unit for a layout. A Node has several types \u2014 <code>hsplit</code>, <code>vsplit</code> and <code>leaf</code>. This corresponds to the <code>root:split-{up,down,left,right}</code> commands. A <code>hsplit</code> and <code>vsplit</code> Node has two children while a <code>leaf</code> node does not.</p> <p>To get the Node for a View, you can call <code>Node:get_node_for_view()</code>. This function recursively searches for the view to find its parent node. You can call <code>RootView:get_node_for_view()</code> to search the entire layout.</p> <p>After you got the Node containing the View, you can also call <code>Node:get_view_idx()</code>. This function will return the index of the View in the Node if the Node contains multiple Views.</p>"},{"location":"developer-guide/views/#adding-views-to-the-layout","title":"Adding Views to the layout","text":"<p>To split a Node, you can call <code>Node:split(direction, view, locked, resizable)</code>. This function takes 2 to 4 arguments, and returns the new Node containing the View passed into the function.</p> <p><code>dir</code> specifies the split direction \u2014 <code>up</code>, <code>down</code>, <code>left</code> and <code>right</code>, and <code>view</code> is the View to add to the new Node.</p> <p><code>locked</code> is a table in the form <code>{ x = true, y = true }</code>. <code>x</code> and <code>y</code> corresponds to the axis of the new Node to \"lock\". A locked axis has a fixed size and cannot be resized by the user.</p> <p><code>resizable</code> is also a table with the same format as <code>locked</code>, and corresponds to axes that will be resizable by the user. This table overrides the options in <code>locked</code>.</p> <p>Following the example above, if we want to add a command to open our View on the bottom, we can do:</p> <pre><code>command.add {\n  [\"hello:split-down\"] = function()\n    -- the new Node will have a fixed initial size based on\n    -- what the View provides, but the user can resize it.\n    -- The other (old) Node will take up the rest of the space.\n    core.root_view:get_active_node():split(\"down\", view, { y = true }, { y = true })\n  end\n}\n</code></pre> <p>Other than splitting the current node, you can also add the View to an existing Node. To do this, use <code>Node:add_view()</code>. This function accepts a View and optionally an index to insert the View to.</p>"},{"location":"developer-guide/views/#remove-views","title":"Remove Views","text":"<p>To remove a View, you can use <code>Node:remove_view()</code>. This function accepts the RootView and the View to remove. Alternatively, you can use <code>Node:close_view()</code> to close the View as well. This function accepts the same arguments as <code>Node:remove_view()</code>.</p>"},{"location":"developer-guide/views/#overlays","title":"Overlays","text":"<p>Sometimes, drawing outside the View is needed, for instance to render overlays and popups.</p> <p>Lite XL supports this by deferring draw calls after the entirety of RootView has been rendered. To do this, use <code>RootView:defer_draw()</code>.</p> <p>This function takes a callback that can use various <code>renderer</code> draw calls. The callback will be called after RootView (all Views) are rendered.</p> <p>The callback will be discarded after use.</p> <p><code>core.defer_draw()</code> is usually called in the View's render method.</p>"},{"location":"setup/building-from-source/","title":"Build and Installation","text":"<p>Once you have downloaded the source code, you can build Lite XL using Meson. In addition, the <code>build-packages.sh</code> script can be used to compile Lite XL and create an OS-specific package for Linux, Windows or macOS.</p> <p>The following libraries are required:</p> <ul> <li>Lua 5.4</li> <li>SDL2</li> <li>FreeType</li> <li>PCRE2</li> </ul> <p>If they are not found, they will be downloaded and compiled by Meson. Otherwise, if they are present, they will be used to compile Lite XL.</p>"},{"location":"setup/building-from-source/#build-script","title":"Build Script","text":"<p>If you compile Lite XL yourself, it is recommended to use <code>build-packages.sh</code>:</p> <pre><code>bash build-packages.sh -h\n</code></pre> <p>The script will run Meson and create an archive with the application. Lite XL can be easily installed by unpacking the archive in any directory of your choice.</p> <p>On Windows two packages will be created, one called \"portable\" using the <code>data</code> folder next to the executable and the other one using a Unix-like file layout. The portable version conforms to the directory structure of normal Windows programs while the Unix-like file layout is meant for a Unix-like environment.</p> <p>Lite XL does not hard-code any directories and instead relies on environment variables. This allows the package to be run in any directory.</p>"},{"location":"setup/building-from-source/#portable","title":"Portable","text":"<p>When running <code>meson setup</code> you may specify <code>-Dportable=true</code> to install Lite XL as a portable application.</p> <p>Lite XL needs the <code>data</code> directory to run properly. When <code>portable</code> is enabled, Lite XL will use the <code>data</code> directory placed next to the executable. Otherwise, Lite XL will use Unix-like directory locations. It will use <code>$prefix/share/lite-xl</code> for <code>data</code> and the executable will be located in <code>$prefix/bin</code>. <code>$prefix</code> is determined when the application starts such that <code>$prefix/bin</code> corresponds to the location of the executable.</p> <p>The <code>user</code> directory does not depend on the <code>portable</code> option and will always be <code>$HOME/.config/lite-xl</code>. On Windows, <code>$USERPROFILE</code> will be used instead of <code>$HOME</code>.</p>"},{"location":"setup/building-from-source/#linux","title":"Linux","text":"<p>On Debian-based systems the dependencies can be installed using the following commands:</p> <pre><code># To install the required libraries:\nsudo apt install libfreetype6-dev libsdl2-dev libpcre2-dev liblua5.4-dev\n\n# To install Meson:\nsudo apt install meson\n# or pip3 install --user meson\n</code></pre> <p>To build Lite XL with Meson the commands below can be used:</p> <pre><code>meson setup --buildtype=release --prefix &lt;prefix&gt; build\nmeson compile -C build\nDESTDIR=\"$(pwd)/lite-xl\" meson install --skip-subprojects -C build\n</code></pre> <p>where <code>&lt;prefix&gt;</code> depends on the OS you are using: - on Linux is <code>/usr</code> - on macOS application bundle can be <code>\"/Lite XL.app\"</code></p> <p>If you are using a version of Meson below 0.54 you need to use different commands to compile and install:</p> <pre><code>meson setup --buildtype=release build\nninja -C build\nninja -C build install\n</code></pre>"},{"location":"setup/building-from-source/#macos","title":"macOS","text":"<p>macOS is fully supported and a notarized app disk image is provided in GitHub Releases. In addition, the application can be compiled using the generic instructions given above.</p>"},{"location":"setup/building-from-source/#windows-msys2","title":"Windows MSYS2","text":"<p>The build environment chosen for Lite XL on Windows is MSYS2. Follow the installation instructions in the link.</p> <ul> <li>Open <code>MinGW 64-bit</code> or <code>MinGW 32-bit</code> shell from the start menu.</li> <li>Update the MSYS2 installation with <code>pacman -Syu</code></li> <li>Restart the shell</li> <li>Install the dependencies:</li> </ul> <pre><code>pacman -S \\\n  ${MINGW_PACKAGE_PREFIX}-freetype \\\n  ${MINGW_PACKAGE_PREFIX}-gcc \\\n  ${MINGW_PACKAGE_PREFIX}-ninja \\\n  ${MINGW_PACKAGE_PREFIX}-pcre2 \\\n  ${MINGW_PACKAGE_PREFIX}-pkg-config \\\n  ${MINGW_PACKAGE_PREFIX}-python-pip \\\n  ${MINGW_PACKAGE_PREFIX}-SDL2\npip3 install meson\n</code></pre> <p><code>${MINGW_PACKAGE_PREFIX}</code> expands either to <code>mingw-w64-i686</code> or <code>mingw-w64-x86_64</code> depending on the current MSYS2 shell used. You can also use pacboy with the <code>:p</code> suffix.</p>"},{"location":"setup/getting-started/","title":"Getting Started","text":"<p>To get started, grab a release of Lite XL. All the files are available on GitHub, and some package managers provide packages for Lite XL.</p> <ul> <li> <p> Windows</p> <p>For Windows 7 Service Pack 2 and above.</p> <ul> <li>64-bit Installer</li> <li>64-bit ZIP</li> <li>32-bit Installer</li> <li>32-bit ZIP</li> </ul> <p> Installation Instructions</p> </li> <li> <p> Linux</p> <p>For Ubuntu 18.04 and above.</p> <ul> <li>64-bit AppImage</li> <li>64-bit tarball</li> <li>.</li> <li>.</li> </ul> <p> Installation Instructions</p> </li> <li> <p> macOS</p> <p>For OSX El Capitan and above.</p> <ul> <li>Intel Mac DMG</li> <li>Apple Silicon Mac DMG</li> <li>Universal DMG</li> <li>.</li> </ul> <p> Installation Instructions</p> </li> <li> <p> Source Code</p> <p>Meson and a C11 compiler needed.</p> <ul> <li>Source tarball</li> <li>Source ZIP</li> <li>.</li> <li>.</li> </ul> <p> Build Instructions</p> </li> </ul>"},{"location":"setup/getting-started/#base-and-addons-packages","title":"Base and Addons Packages","text":"<p>Since Lite XL v2.1.0, we provide two releases per platform \u2014 the base and addons packages. The base release contains a minimal release of Lite XL and essential plugins, while the addons package contains a full suite of plugins and syntax-highlighting support out-of-the-box.</p> <p>Most users should choose the addons package as it provides most features out-of-the-box. However, if you plan to customize Lite XL from scratch, the base release is for you.</p> <p>The addons package is going away.</p> <p>We know that this dual-package convention is confusing, so we are working on lpm to enable users to customize their plugins on first launch.</p>"},{"location":"setup/getting-started/#windows","title":"Windows","text":"<p>On Windows, Lite XL is available as an installer or a zip archive. To use the installer, simply run it and follow the steps outlined by the installer.</p> <p>To install Lite XL from a zip archive, extract it to a directory and run it directly.</p> Never run Lite XL directly from the zip archive. <p>Lite XL requires extra files that are present in the zip archive to function. Running it may cause crashes or unexpected errors.</p>"},{"location":"setup/getting-started/#linux","title":"Linux","text":"<p>Linux distributions usually install packages via their respective package managers. If a package is available for your distribution, you can install it from there.</p> <p>Lite XL is available as an AppImage or tarballs. For AppImages, you can simply make it executable and run it.</p> If you encounter issues with the AppImage, verify whether fuse is installed. <p>AppImages require FUSE to function. Please visit [AppImage Troubleshooting Guide][appimage-troubleshoot] for details.</p> <p>To install Lite XL from a tarball, you should extract it to a temporary directory and move each files into place. For instance:</p> <pre><code>tar -xzf &lt;file&gt;\ncd lite-xl\n\n# to run Lite XL without installing, simply do the following:\n# ./lite-xl\n\n# remove previous installation files\nrm -rf $HOME/.local/share/lite-xl $HOME/.local/bin/lite-xl\nmkdir -p $HOME/.local/bin &amp;&amp; cp lite-xl $HOME/.local/bin\nmkdir -p $HOME/.local/share/lite-xl &amp;&amp; cp -r data/* $HOME/.local/share/lite-xl\n</code></pre> <p>You may encounter older releases that has the files laid out in the correct directories (e.g. <code>bin</code>, <code>share</code>); in that case copying them to your installation directory (<code>$HOME/.local</code> or <code>/usr</code>) is sufficient.</p>"},{"location":"setup/getting-started/#adding-lite-xl-to-path","title":"Adding Lite XL to PATH","text":"<p>If you can't launch Lite XL from the terminal after installation, you need to put <code>$HOME/.local/bin</code> into PATH. Instructions may vary according to your shell, but for bash, simply run the following line:</p> <pre><code>echo -e 'export PATH=$PATH:$HOME/.local/bin' &gt;&gt; $HOME/.bashrc\n</code></pre>"},{"location":"setup/getting-started/#lite-xl-icon-not-showing-on-app-launchers","title":"Lite XL icon not showing on app launchers","text":"<p>On certain systems, you might want to run the following command to update the cache:</p> <pre><code>xdg-desktop-menu forceupdate\n</code></pre>"},{"location":"setup/getting-started/#macos","title":"macOS","text":"<p>Installation on macOS is fairly straightforward \u2014 we provide DMG files that you can mount and drag-and-drop Lite XL into your Applications folder.</p> <p>For older versions of Lite XL (before v2.1.2), you will need to clear App attributes from the application to launch it. To do so,  you need to run the following command:</p> <pre><code>$ xattr -cr /Applications/Lite\\ XL.app\n</code></pre> <p>For releases v2.1.2 and above, you just need to right-click on Lite XL in Finder and click \"Open\". If this is your first time launching Lite XL, macOS will display a prompt. Click \"OK\" and the Lite XL will launch.</p>"},{"location":"setup/getting-started/#other-platforms","title":"Other Platforms","text":"<p>Lite XL does not produce binary releases for other platforms. To run the editor in other platforms, you may want to build Lite XL yourself.</p>"},{"location":"setup/getting-started/#portable-mode","title":"Portable mode","text":"<p>Lite XL searches <code>(directory to lite-xl.exe)/user</code> for configuration, which allows users to create portable installations that doesn't use the user's configuration.</p> <p>To create a portable installation, simply create a <code>user</code> directory where Lite XL executable is located.</p>"},{"location":"setup/getting-started/#issues-and-workarounds","title":"Issues and workarounds","text":"<p>Lite XL may have issues on certain platforms that can be worked around by the user. A list of issues and workarounds are documented here.</p>"},{"location":"setup/install-from-package-managers/","title":"Installation from Package Managers","text":"<p>Lite XL is available on some package managers. Other package managers may require you to configure extra sources in order to install Lite XL.</p> <p>Note</p> <p>The only official source of Lite XL binaries are from GitHub. Be careful when installing packages from a third party.</p>"},{"location":"setup/install-from-package-managers/#linux","title":"Linux","text":"<p>Lite XL is available on many distributions' package managers. Here are some instructions on how to install Lite XL on certain distributions.</p>"},{"location":"setup/install-from-package-managers/#alpine-linux","title":"Alpine Linux","text":"<p>You need to enable the <code>testing</code> repository by uncommenting the relevant line in <code>/etc/apk/repositories</code>:</p> <pre><code>#/media/cdrom/apks\nhttp://dl-cdn.alpinelinux.org/alpine/v3.16/main\n#http://dl-cdn.alpinelinux.org/alpine/v3.16/community\n#http://dl-cdn.alpinelinux.org/alpine/edge/main\n#http://dl-cdn.alpinelinux.org/alpine/edge/community\nhttp://dl-cdn.alpinelinux.org/alpine/edge/testing\n</code></pre> <p>Afterwards, update the package database and install Lite XL:</p> <pre><code>apk update\napk add lite-xl\n</code></pre>"},{"location":"setup/install-from-package-managers/#arch-linux-via-aur","title":"Arch Linux (via AUR)","text":"<p>Packages for Arch Linux are available as 3 AUR repositories: <code>lite-xl</code>, <code>lite-xl-git</code> and <code>lite-xl-bin</code>.</p> <p>To install, you can clone the git repository to a working directory and run <code>makepkg</code>:</p> <pre><code>git clone https://aur.archlinux.org/lite-xl.git\ncd lite-xl\nmakepkg -si\n</code></pre> <p>Alternatively, install it via an AUR helper such as yay.</p>"},{"location":"setup/install-from-package-managers/#fedora","title":"Fedora","text":"<p>Lite XL can be installed on Fedora 37 with the command:</p> <pre><code>dnf install lite-xl\n</code></pre> <p>A Copr also provides nightly releases. To install it, enable the <code>sentry/lite</code> Copr and install the appropriate package.</p> <pre><code>dnf copr enable sentry/lite\ndnf install lite-xl-nightly\n</code></pre>"},{"location":"setup/install-from-package-managers/#gnu-guix","title":"GNU Guix","text":"<p>Lite XL can be installed via Guix with the command:</p> <pre><code>guix install lite-xl\n</code></pre>"},{"location":"setup/install-from-package-managers/#debian-based-via-mpr","title":"Debian-based (via MPR)","text":"<p>makedeb provides an AUR-like experience to install Lite XL.</p> <p>First, install makedeb:</p> <pre><code>bash -ci \"$(wget -qO - 'https://shlink.makedeb.org/install')\"\n</code></pre> <p>Then, clone the git repository into a working directory and run <code>makedeb</code>:</p> <pre><code>git clone https://mpr.makedeb.org/lite-xl.git\ncd lite-xl\nmakedeb -s\n</code></pre>"},{"location":"setup/install-from-package-managers/#nix","title":"Nix","text":"<p>Lite XL can be installed on Nix via <code>nix-env</code>.</p> <pre><code>nix-env -i lite-xl\n</code></pre>"},{"location":"setup/install-from-package-managers/#opensuse-tumbleweed","title":"openSUSE Tumbleweed","text":"<p>Lite XL can be installed on openSUSE Tumbleweed via <code>zypper</code>:</p> <pre><code>zypper install lite-xl\n</code></pre>"},{"location":"setup/install-from-package-managers/#void-linux","title":"Void Linux","text":"<p>Lite XL can be installed on Void Linux with the following command:</p> <pre><code>xbps-install lite-xl\n</code></pre>"},{"location":"setup/install-from-package-managers/#windows","title":"Windows","text":"<p>Windows doesn't use package managers in general \u2014 we recommend installing Lite XL via GitHub. However, Lite XL is available in Chocolatey and Scoop.</p>"},{"location":"setup/install-from-package-managers/#chocolatey","title":"Chocolatey","text":"<p>Lite XL can be installed on Chocolatey with the following command:</p> <pre><code>choco install lite-xl\n</code></pre>"},{"location":"setup/install-from-package-managers/#scoop","title":"Scoop","text":"<p>Lite XL can be installed on Scoop by installing the Extras manifest and installing the package:</p> <pre><code>scoop bucket add extras\nscoop install lite-xl\n</code></pre>"},{"location":"setup/install-from-package-managers/#macos","title":"macOS","text":""},{"location":"setup/install-from-package-managers/#macports","title":"MacPorts","text":"<p>Lite XL is available via MacPorts:</p> <pre><code>sudo port install lite-xl\n</code></pre>"},{"location":"setup/platform-notes/","title":"Platform-Specific Notes","text":""},{"location":"setup/platform-notes/#windows","title":"Windows","text":""},{"location":"setup/platform-notes/#portable-application","title":"Portable application","text":"<p>The installer provides a \"Portable Mode\" checkbox which can be used to extract Lite XL into a directory. If this mode is enabled, the installer will not allow user to uninstall Lite XL from the Settings / Control Panel. Users can just delete the installation folder.</p> <p>Note</p> <p>This is different from the Portable Mode mentioned in Getting Started. The Portable Mode checkbox will not create the <code>user</code> directory, thus the installation will use the user's configuration.</p>"},{"location":"setup/platform-notes/#32-bit-support","title":"32-bit support","text":"<p>32-bit builds of Lite XL are provided, but they are not actively tested for bugs. These builds have platform suffix \"i386\".</p>"},{"location":"setup/platform-notes/#custom-window-decoration","title":"Custom window decoration","text":"<p>Windows users may notice that the title bar (window decoration) does not follow device theme. This is a known upstream issue related to SDL.</p> <p>In the meantime, there are a few workarounds:</p> <ol> <li>Enable the custom title bar by setting <code>config.borderless</code> to <code>true</code> in <code>init.lua</code>.    The custom title bar will follow Lite XL's color scheme.</li> <li>Install the immersive-title plugin.    This approach will preserve Windows' title bar while having the correct    appearance on theme change.</li> </ol> <p>The first option can be enabled with the following steps.</p> User ModuleSettings UI <pre><code>local config = require \"core.config\"\nconfig.borderless = true\n</code></pre> <p>Toggle the \"Borderless\" checkbox under Core &gt; User Interface. </p>"},{"location":"setup/platform-notes/#linux","title":"Linux","text":""},{"location":"setup/platform-notes/#32-bit-support_1","title":"32-bit support","text":"<p>Unfortunately, Lite XL does not provide binary packages for 32-bit systems. You may want to compile Lite XL yourself.</p> 32-bit version of Lite XL is not actively tested for bugs. <p>Due to a lack of testers, we've only been able to test whether the code can compile on a 32-bit system. This does not mean that Lite XL may run correctly.</p>"},{"location":"setup/platform-notes/#portable-packages","title":"Portable packages","text":"<p>Since v2.1.0, only portable packages are provided. These packages do not follow the UNIX Filesystem Hierarchy Standard (FHS).</p> <pre><code>lite-xl/\n  \\- data/\n  \\- doc/\n  \\- lite-xl\n</code></pre> <p>To install the portable package according to the FHS, do the following:</p> <ol> <li>Move <code>data/</code> to <code>/usr/share/lite-xl</code>.</li> <li>Move <code>doc/</code> to <code>/usr/share/doc/lite-xl</code></li> <li>Move <code>lite-xl</code> to <code>/usr/bin/lite-xl</code></li> </ol>"},{"location":"setup/platform-notes/#client-side-decorations","title":"Client-side decorations","text":"<p>Certain Wayland desktops does not provide server-side decorations. By default, Lite XL (SDL under the hood) will use <code>libdecor</code> to draw client-side decorations.</p> <p>To work around this, set <code>config.borderless</code> to <code>true</code>. Lite XL will draw a client-side decoration.</p> User ModuleSettings UI <pre><code>local config = require \"core.config\"\nconfig.borderless = true\n</code></pre> <p>Toggle the \"Borderless\" checkbox under Core &gt; User Interface. </p>"},{"location":"user-guide/configuration/","title":"Configuration","text":""},{"location":"user-guide/configuration/#location","title":"Location","text":"<p>Lite XL searches a list of paths to store user configuration, known as <code>USERDIR</code>. The first path that is available will be used.</p> <ol> <li><code>(path to lite-xl.exe)/user</code></li> <li><code>$LITE_USERDIR</code></li> <li><code>$XDG_CONFIG_HOME/lite-xl</code></li> <li><code>$HOME/.config/lite-xl</code></li> </ol> <p>On Windows, <code>$HOME</code> will be replaced with <code>$USERPROFILE</code>.</p>"},{"location":"user-guide/configuration/#user-module","title":"User Module","text":"<p>Lite XL is mainly configured through the user module. The user module is a Lua script run by Lite XL during startup, before plugins are loaded. Thus, you can change configuration options, bind shortcut keys, load color schemes, change the fonts among other things.</p> <p>To modify the user module, you can run the command <code>core:open-user-module</code>. You can also modify the file <code>USERDIR/init.lua</code> directly. Lite XL will reload the file on file change.</p>"},{"location":"user-guide/configuration/#project-module","title":"Project Module","text":"<p>The project module is an optional module which is loaded from the current project's directory when Lite XL is started. Project modules can be useful for things like adding custom commands for project-specific build systems, or loading project-specific plugins.</p> <p>The project module is loaded when the editor starts, after the user module is loaded but before plugins are loaded.</p> <p>To modify project module, you can run the command <code>core:open-project-module</code>. The command will create a project module if it does not exist.</p>"},{"location":"user-guide/configuration/#settings-gui","title":"Settings GUI","text":"<p>Since Lite XL v2.1.0, we started bundling the settings plugin. This plugin provides a GUI to configure Lite XL.</p> <p>Warning</p> <p>You mustn't set the same configuration option in the user module and the Settings GUI at the same time. This can result in undefined behavior.</p>"},{"location":"user-guide/configuration/#fonts","title":"Fonts","text":"<p>Lite XL comes with JetBrains Mono and Fira Sans by default. JetBrains Mono is used for the editor itself while Fira Sans is used for other UI elements.</p> <p>To change the fonts used by the editor, you can change the variable <code>style.font</code> and <code>style.code_font</code>. These variables are responsible for the UI font and code font respectively.</p> <p>To load a font, you can use <code>renderer.font.load()</code>. This function allows you to load a font file as long as it is supported by FreeType. The function takes in the path to the font file and the pixel size of the font.</p> <p>When displaying text with multiple languages, multiple fonts are often required. Lite XL supports fallback fonts by using the function <code>renderer.font.group()</code>. This function takes in a table of fonts loaded by <code>renderer.font.load()</code>. Lite XL will attempt to render fonts based on the order the fonts are added to the table.</p> User ModuleSettings GUI <p>For this example, we'll load Noto Sans Mono, which is located in <code>/usr/share/fonts/noto/NotoSansMono-Regular.ttf</code> and set it as our code font.</p> <pre><code>local style = require \"core.style\"\n-- SCALE is the pixel scaling required for the current DPI setup.\n-- This converts the font size from points to pixels.\nstyle.code_font = renderer.font.load(\"/usr/share/fonts/noto/NotoSansMono-Regular.ttf\", 15 * SCALE)\n</code></pre> <p>Next, we'll also load Noto Sans SC, which is located in <code>/usr/share/fonts/noto-cjk/NotoSansCJK-Regular.ttc</code> and use it as fallback.</p> <pre><code>local style = require \"core.style\"\n-- do not ever do style.code_font = { style.code_font, ... }\n-- style.code_font can be a font group and lite-xl does not\n-- support nested font groups!\nstyle.code_font = renderer.font.group {\n  renderer.font.load(\"/usr/share/fonts/noto/NotoSansMono-Regular.ttf\", 15 * SCALE),\n  renderer.font.load(\"/usr/share/fonts/noto-cjk/NotoSansCJK-Regular.ttc\", 15 * SCALE)\n}\n</code></pre> <p>Tip</p> <p>Lite XL does not support using a specfific face in a TrueType collection (.ttc) file. Only the first face can be used.</p> <p>To change the code font, navigate to the \"Core\" tab and expand the \"Editor\" section. The first entry should be a list of code fonts used by the editor. </p> <p>To add a new font, click the \"Add\" button. A font selector will be shown. </p> <p>To choose a font, press the \"Mono\" button and select a font from the list. The \"All\" button allows you to select non-monospace fonts.</p> <p>A demo text will be shown at the textbox on the top of the selector. To change the antialiasing settings of the font, click on the dropdown to the left. To change the hinting settings of the font, click on the dropdown to the right. The changes will be reflected automatically on the preview window. Press \"Save\" to add the font or \"Cancel\" to go back.</p> <p>If you have more than one fonts set up, you can change the fallback order by pressing the \"\u2039\" and \"\u203a\" buttons. </p>"},{"location":"user-guide/configuration/#keyboard-shortcuts","title":"Keyboard shortcuts","text":"<p>Keyboard shortcuts are managed by the <code>core.keymap</code> module. This module maps keyboard shortcuts to one or more commands, where each command has a predicate that determine whether it can be run.</p> <p>For a list of default keyboard shortcuts, check out these pages:</p> <ul> <li>non-macOS platforms (Windows, Linux, etc.)</li> <li>macOS</li> </ul>"},{"location":"user-guide/configuration/#adding-a-keyboard-shortcut","title":"Adding a keyboard shortcut","text":"<p>To add keyboard shortcuts, you can use <code>keymap.add()</code>.</p> User ModuleSettings UI <p>For example, to bind Ctrl+M to move the cursor backwards and then upwards, do:</p> <pre><code>local keymap = require \"core.keymap\"\nkeymap.add {\n  [\"ctrl+m\"] = \"doc:move-to-previous-char\"\n}\nkeymap.add {\n  [\"ctrl+m\"] = \"doc:move-to-previous-line\"\n}\n</code></pre> <p>Lite XL will automatically execute both commands in the order that they're added.</p> <p>Alternatively, to override a keyboard shortcut completely, add <code>true</code> on the second parameter of <code>keybind.add()</code>.</p> <pre><code>local keymap = require \"core.keymap\"\nkeymap.add {\n  [\"ctrl+m\"] = \"doc:move-to-previous-char\"\n}\nkeymap.add({\n  [\"ctrl+m\"] = \"doc:move-to-previous-line\"\n}, true)\n</code></pre> <p>This will cause Lite XL to only run <code>core:move-to-previous-line</code> when Ctrl+M is pressed.</p> <p>Navigate to the \"Keybindings\" tab. </p> <p>Scroll until you find the entry containing the command you want to bind to and click on it. In recent versions of the Settings plugin, you can also search for commands with the text box on top. In this example, we'll pick <code>doc:move-to-previous-char</code>.</p> <p>To add a keybind, press the \"Add\" and press the key combination that you want to bind to. Afterwards, press \"Save\". </p> <p>If the keyboard shortcut is set properly, you will see the updated keyboard shortcut on the \"Bindings\" section at the right. </p> <p>To replace previous keyboard shortcuts, simply delete any existing keyboard shortcut via the \"Remove\" button, then re-add it.</p>"},{"location":"user-guide/configuration/#removing-a-keyboard-shortcut","title":"Removing a keyboard shortcut","text":"<p>To remove an existing keyboard shortcut, you can use <code>keymap.unbind()</code>.</p> User ModuleSettings UI <p>In this example, we will unbind Ctrl+M.</p> <pre><code>local keymap = require \"core.keymap\"\nkeymap.unbind(\"ctrl+m\", \"doc:move-to-previous-line\")\nkeymap.unbind(\"ctrl+m\", \"doc:move-to-previous-char\")\n</code></pre> <p>This will unbind the two commands from Ctrl+M.</p> <p>Alternatively, to unbind all commands from Ctrl+M, you can omit the second parameter to <code>keymap.unbind()</code>.</p> <pre><code>local keymap = require \"core.keymap\"\nkeymap.unbind(\"ctrl+m\", \"doc:move-to-previous-line\")\nkeymap.unbind(\"ctrl+m\", \"doc:move-to-previous-char\")\n</code></pre> <p>Navigate to the \"Keybindings\" tab. </p> <p>Scroll until you find the entry containing the command you want to bind to and click on it. In recent versions of the Settings plugin, you can also search for commands with the text box on top. In this example, we pick <code>doc:move-to-previous-char</code>.</p> <p>To remove a keyboard shortcut, select the shortcut you want to remove and press the \"Remove\" button. Afterwards, press the \"Save\" button to save the changes. </p>"},{"location":"user-guide/configuration/#themes","title":"Themes","text":"<p>The default theme is a dark theme. Themes are implemented as plugins that changes the styling variables of Lite XL.</p> <p>This can be changed with <code>core.reload_module()</code> and loading the appropriate theme file.</p> User ModuleSettings GUI <p>To load the theme <code>summer</code>, add <code>core.reload_module \"colors.summer\"</code>.</p> <pre><code>core.reload_module \"color.summer\"\n</code></pre> <p>Navigate to the \"Colors\" tab.</p> <p></p> <p>Select your desired theme. The colors should apply immediately.</p>"},{"location":"user-guide/configuration/#other-options","title":"Other options","text":"<p>There are a lot of configuration options that can be modified. A list of these options can be found in <code>data/core/config.lua</code>, but we'll list a few common ones here.</p>"},{"location":"user-guide/configuration/#indentation","title":"Indentation","text":"<p>To change the indentation size and type, set <code>config.indent_size</code> and <code>config.tab_type</code> respectively.</p> <pre><code>local config = require \"core.config\"\nconfig.indent_size = 4 -- set indentation to 4\nconfig.tab_type =      -- \"soft\" for spaces, \"hard\" for tabs\n</code></pre>"},{"location":"user-guide/configuration/#window-decoration","title":"Window decoration","text":"<p>If you're on platforms such as Wayland where window decoration may be client drawn, you can set <code>config.borderless</code> to <code>true</code>. This will let Lite XL draw its own window decoration.</p> <pre><code>local config = require \"core.config\"\n-- enable custom window borders\nconfig.borderless = true\n</code></pre>"},{"location":"user-guide/configuration/#project-files-limit","title":"Project files limit","text":"<p>When opening large directories, Lite XL will often complain about reaching the project file limit. This is because Lite XL becomes slower when it needs to index these files on startup.</p> <p>If your filesystem has good performance, you can increase this limit by setting <code>config.max_project_files</code> to something else. The default value is 2000.</p> <pre><code>local config = require \"core.config\"\n-- set max project files to 5000\nconfig.max_project_files = 5000\n</code></pre>"},{"location":"user-guide/configuration/#ignoring-files","title":"Ignoring files","text":"<p>Lite XL does not index certain files and directories by default, such as version control and executables. This can be modified by changing <code>config.ignore_files</code>. This value is a table of Lua patterns. For directories, the pattern ends with a forward slash (<code>/</code>). For files, the pattern ends with the end anchor (<code>$</code>).</p> <pre><code>local config = require \"core.config\"\n-- ignore .data/\ntable.insert(config.ignore_files, \"^%.data/\")\n</code></pre>"},{"location":"user-guide/configuration/#caret","title":"Caret","text":"<p>You can disable or change the blinking rate of the caret.</p> <pre><code>local config = require \"core.config\"\nconfig.disable_blink = true -- disable caret blinking\nconfig.blink_period = 0.4 -- change caret blink rate\n</code></pre>"},{"location":"user-guide/configuration/#fps-frame-rate","title":"FPS (Frame rate)","text":"<p>The default frame rate is set to 60. If this causes an issue, you can set it via <code>config.fps</code>.</p> <pre><code>local config = require \"core.config\"\n-- set FPS to 30\nconfig.fps = 30\n</code></pre>"},{"location":"user-guide/configuration/#transitions","title":"Transitions","text":"<p>You can disable any animations/transitions by setting <code>config.transitions</code> to <code>false</code>. To disable individual transitions, you can set any member of <code>config.disabled_transitions</code> to <code>true</code>.</p> <pre><code>local config = require \"core.config\"\n-- disable all transitions\nconfig.transitions = false\n-- disable commandview and scroll transitions\nconfig.disabled_transitions = {\n  commandview = true,\n  scroll = true\n}\n</code></pre> <p>To change the animation rate, set <code>config.animation_rate</code>.</p> <pre><code>local config = require \"core.config\"\n-- slow down the animations to half speed\nconfig.animation_rate = 0.5\n</code></pre>"},{"location":"user-guide/configuration/#other-options_1","title":"Other options","text":"A quick reference of other options. Options Description <code>max_log_items</code> Maximum number of log items to store before discarding them. <code>message_timeout</code> Time (seconds) to show each message on the StatusView. <code>mouse_wheel_scroll</code> Number of pixels per \"scroll\". <code>animate_drag_scroll</code> Enable smooth scrolling. <code>force_scrollbar_status</code> Always expand (<code>\"expanded\"</code>) or hide (<code>\"contracted\"</code>) the scrollbar. <code>file_size_limit</code> File size limit (MB) before Lite XL refuses to load it. <code>symbol_pattern</code> Lua pattern used by Lite XL to find symbols. <code>non_word_chars</code> A pattern used to find non-word characters. <code>undo_merge_timeout</code> Time (seconds) before Lite XL merges edits to form a single undo step. <code>max_undos</code> Number of undo to store per document. <code>max_tabs</code> Number of tabs to show before overflowing. <code>always_show_tabs</code> If true, always show tabs even if only one file is open. <code>highlight_current_line</code> Highlights the current line. <code>line_height</code> The spacing between each line. <code>keep_newline_whitespace</code> If true, removes any line that only contains whitespace (space, tabs, etc.) <code>line_limit</code> An advisory limit for characters per line. <code>tab_close_button</code> Shows or hides the tab close button for each tab. <code>max_clicks</code> Maximum number of clicks you can perform in the editor."},{"location":"user-guide/configuration/#plugins","title":"Plugins","text":"<p>Since the user and project module loads before any plugins, you can configure or disable any plugins in the user and project modules. Plugins obtain their configuration from a table in the <code>config.plugins</code> table. You can add code to user module that modifies the table.</p> <p>To disable a plugin, you need to set the associated <code>config.plugins</code> entry to <code>false</code>. This tells Lite XL to not load the plugin on startup. It will not load nor unload the plugin from the current instance.</p> Some plugins may have options to enable/disable themselves. <p>This allows the plugins to be loaded and toggled without a restart.</p> User ModuleSettings GUI <p>In this example, we'll enable the <code>drawwhitespace</code> plugin and set it to only draw whitespaces in the selected text.</p> <pre><code>local config = require \"core.config\"\nconfig.plugins.drawwhitespace = {\n  show_selected_only = true\n}\n</code></pre> <p>To disable the plugin, simply assign <code>config.plugins.drawwhitespace</code> to <code>false</code>.</p> <pre><code>local config = require \"core.config\"\nconfig.plugins.drawwhitespace = false\n</code></pre> <p>Navigate to the \"Plugins\" tab.</p> <p>In this tab, you will find many sections dedicated to each plugin, as well as an \"Installed\" section where you can enable/disable the plugins.</p> <p>To enable the <code>drawwhitespace</code> plugin, expand the \"Installed\" section and enable the corresponding plugin.</p> <p></p> <p>To modify the configuration for a plugin, expand the relevant section. The changes will apply automatically. </p>"},{"location":"user-guide/ide-setup/","title":"Setup Lite XL as an IDE","text":"<p>Lite XL can be configured to be a proper IDE for most programming languages. The following is a brief overview of the plugins that, when used together, provide the experience of a minimal and modern IDE.</p>"},{"location":"user-guide/ide-setup/#bells-and-whistles","title":"Bells and Whistles","text":"<p>The following plugins are meant to enrich Lite XL with handy features that improve the coding experience:</p> <ul> <li><code>autoinsert</code> and <code>lfautoinsert</code> add automatic bracket/quote insertion and text-wrapping.</li> <li><code>autosave</code> allows automatic file saving after every change.</li> <li><code>bracketmatch</code> underlines brackets matching pairs under the caret.</li> <li><code>colorpreview</code> underlays color values (e.g. <code>#ff00ff</code> or <code>rgb(255, 0, 255)</code>) with their respective color.</li> <li><code>indentguide</code> adds indent guides to make it easier to see function boundaries.</li> <li><code>rainbowparen</code> applies rainbow colors to nesting parentheses to make it easier to distinguish them.</li> <li><code>scalestatus</code> displays current scale (zoom) in the status view (it depends on the <code>scale</code> plugin).</li> <li><code>selectionhighlight</code> highlights regions of code that match the current selection,    to preview for search/replace actions.</li> <li><code>sticky_scroll</code> keeps track of the current scope at the top of the view.</li> <li><code>minimap</code> adds VSCode's minimap.</li> <li><code>devicons</code> provides fancy icons in the project treeview for many file types.</li> <li><code>meta_colors</code> installs all available theme files.</li> </ul>"},{"location":"user-guide/ide-setup/#syntax-highlighting","title":"Syntax Highlighting","text":"<p><code>meta_languages</code> installs all supported syntax-highlighting plugins.</p>"},{"location":"user-guide/ide-setup/#intellisense","title":"Intellisense","text":"<p><code>lsp</code> is a plugin that provides support for Intellisense (LSP protocol), while <code>lintplus</code> provides support for linters in case a LSP server lacks an integrated linter.</p> <p>There is also <code>lsp_snippets</code>, which adds snippets support from <code>lsp</code> to the <code>snippets</code> plugin.</p> <p><code>lsp</code> can be configured manually by following the official guide, or it can interface with  the <code>lite-xl-lsp-servers</code> repository that allows the installation of bundled LSP servers, which don't  require manual configuration.</p> <p>An example of installing bundled LSP servers is <code>lpm install lsp_rust</code> which installs the binary  files required to run <code>rust-analyzer</code>.</p>"},{"location":"user-guide/ide-setup/#code-snippets","title":"Code Snippets","text":"<p><code>snippets</code> adds support for code snippets.</p> <p>Snippets can easily be added by following the official guide.</p>"},{"location":"user-guide/ide-setup/#code-formatters","title":"Code Formatters","text":"<p><code>formatter</code> provides file-specific formatting for several programming languages.</p>"},{"location":"user-guide/ide-setup/#integrated-terminal","title":"Integrated Terminal","text":"<p><code>lite-xl-terminal</code> provides an integrated terminal.</p>"},{"location":"user-guide/ide-setup/#version-control","title":"Version Control","text":"<p><code>scm</code> provides source code control integration to Lite XL.</p> <p><code>gitblame</code> can be added to show git commit information of the line where the cursor rests.</p>"},{"location":"user-guide/ide-setup/#todo-treeview","title":"TODO Treeview","text":"<p><code>todotreeview</code> is a plugin that adds a custom treeview with the goal of keeping tracks of  flagged comments (TODO, WIP, FIX, ...) for better workflow organization.</p> <p>More flags can be added in the <code>init.lua</code> following the official guide.</p>"},{"location":"user-guide/ide-setup/#build-integration","title":"Build Integration","text":"<p><code>build</code> provides a build system, messages window, and easily clickable errors.</p> <p>At the moment it only supports <code>make</code>, but it can be extended to any build system.</p>"},{"location":"user-guide/ide-setup/#debug-integration","title":"Debug Integration","text":"<p><code>debugger</code> provides debugger integration, with pluggable backends.</p> <p>At the moment it only supports <code>gdb</code>.</p>"},{"location":"user-guide/ide-setup/#automatic-setup","title":"Automatic Setup","text":"<p>The following examples are configurations and scripts that bundle together the essential components  of a minimal IDE:</p> <ul> <li>Adam's configuration is made for C/C++ and features custom plugins for building and debugging.</li> <li>PerilousBooklet's configuration (WIP) contains an installation script that prepares a    comprehensive IDE configuration similar to a minimal version of VSCode, aimed at supporting    the most used programming languages.</li> </ul>"},{"location":"user-guide/introduction/","title":"Introduction","text":""},{"location":"user-guide/introduction/#opening-files","title":"Opening files","text":"<p>Lite XL comes with a file browser by default. You can open, rename, move and delete files with it. Right-clicking on a file or folder will show more options.</p> <p>Other than that, you can also open files with Ctrl+P. This opens a fuzzy finder with a list of project files.</p> <p></p>"},{"location":"user-guide/introduction/#commands","title":"Commands","text":"<p>Most of Lite XL's functionalities are implemented as commands and exposed by the command palette. The command palette is bound to Ctrl+Shift+P by default and is used to enter commands and execute them.</p> <p>The command palette supports fuzzy matching, so you don't need to enter the full name of the command. For instance, to create a new file, you can type <code>new doc</code> and the correct command <code>Core: New Doc</code> will show up as the first choice. You can press Up or Down to select other commands. If a command is bound to a key shortcut, it will be shown on the right.</p> <p></p>"},{"location":"user-guide/introduction/#keyboard-shortcuts","title":"Keyboard shortcuts","text":"<p>All keyboard shortcuts are handled by the <code>core.keymap</code> module. A key binding maps a \"stroke\" (e.g. Ctrl+Q) to one or more commands (e.g. <code>core:quit</code>). When the shortcut is pressed Lite XL will iterate each command assigned to that key and run the predicate function for that command \u2014 if the predicate passes it stops iterating and runs the command.</p> <p>A new mapping can be added by your user module as follows:</p> <pre><code>local keymap = require \"core.keymap\"\nkeymap.add { [\"ctrl+q\"] = \"core:quit\" }\n</code></pre> <p>A list of default mappings can be viewed [here][mapping].</p>"},{"location":"user-guide/introduction/#multiple-selections-multiple-cursors","title":"Multiple selections (multiple cursors)","text":"<p>Lite XL supports multiple cursors to edit multiple lines at once. You insert more cursors by Ctrl+Left Button. To insert cursors upwards or downwards, use Ctrl+Shift+Up or Ctrl+Shift+Down.</p> <p></p>"},{"location":"user-guide/introduction/#find-and-replace","title":"Find and replace","text":"<p>To find a certain word, you can use Ctrl+F. This will open a prompt where you can find text in the document. After entering the text, you can press enter to find the first match. The matched text will be selected. To find the next match, press F3</p> <p>By default, Lite XL uses case-insensitive search. Input such as <code>Test</code> will match either <code>Test</code> or <code>test</code>. To toggle case-sensitive search, press Ctrl+I.</p> <p>Lite XL also supports searching with regular expressions. This feature can be enabled by pressing Ctrl+Shift+I. This mode can be used in conjunction with case-sensitive search.</p> <p>To find and replace text, press Ctrl+R. Lite XL will prompt you for text to replace and the replacement text. Afterwards, it will replace all occurrences of the text.</p> <p></p>"},{"location":"user-guide/introduction/#project-search","title":"Project search","text":"<p>Finding text across multiple files can be useful. To do this in Lite XL, press Ctrl+Shift+F. You can then enter the text to find and press enter. Lite XL will open a new tab to display all the search results. To open the file containing the match, you can click the entries.</p> <p>Project search also supports case-sensitive search and regular expressions with the same keyboard shortcuts. <code>project-search:fuzzy-find</code> allows you to search the project for similar words.</p> <p>Lite XL does not support find and replace text across a project.</p> <p></p>"},{"location":"user-guide/introduction/#line-endings","title":"Line endings","text":"<p>Some application may require a specific type of line ending. To change the line ending of a file, you can use the command <code>doc:toggle-line-ending</code> or press the rightmost entry on the StatusView. This should toggle between LF and CRLF which corresponds to Unix and Windows style line endings.</p> <p></p>"},{"location":"user-guide/introduction/#indentation","title":"Indentation","text":"<p>Lite XL should automatically detect the indentation of the current file and apply it when pressing Tab. However, you can change the indentation size by left-clicking the 4<sup>th</sup> entry on the right of the StatusView. You can also change the type of the indentation by right-clicking the entry. The settings will not apply to existing text.</p> <p></p>"},{"location":"user-guide/introduction/#projects","title":"Projects","text":"<p>Lite XL centers around the concept of projects \u2014 a project contains your code and project-specific configuration. A project contains at least one project directory. Project directories are where your code is stored.</p> <p>To use open a directory as a project, the directory name can be passed as a command-line argument or the directory can be dragged onto either the executable or a running instance. Once loaded, the project can be changed using the command <code>core:change-project-folder</code>. The command will close all the documents currently opened and switch to the new project. If you want to open a project in a new window, the command <code>core:open-project-folder</code> will open a new editor window with the selected project.</p> <p>Projects may contain multiple directories. To add a directory to the current project, you can use the command <code>core:add-directory</code>. Once the directory is added to the project, you can browse its file on the file browser and fuzzy finder.</p> <p>Lite XL will automatically save opened files and directories and restore them when you restart the editor.</p>"},{"location":"user-guide/keymap/","title":"Keymap","text":"<p>This is the default keyboard shortcuts on non-macOS platforms. Your configuration may differ as plugins can modify them.</p> Command Keys <code>autocomplete:cancel</code> Esc <code>autocomplete:complete</code> Tab <code>autocomplete:next</code> Down <code>autocomplete:previous</code> Up <code>command:complete</code> Tab <code>command:escape</code> Esc <code>command:select-next</code> Down <code>command:select-previous</code> Up <code>command:submit</code> Enter , Num Enter <code>context:focus-next</code> Down <code>context:focus-previous</code> Up <code>context:hide</code> Esc <code>context:on-selected</code> Enter <code>context:show</code> Menu <code>core:change-project-folder</code> Ctrl+Shift+C <code>core:find-command</code> Ctrl+Shift+P <code>core:find-file</code> Ctrl+P <code>core:new-doc</code> Ctrl+N <code>core:open-file</code> Ctrl+O <code>core:open-project-folder</code> Ctrl+Shift+O <code>core:restart</code> Ctrl+Alt+R <code>core:toggle-fullscreen</code> F11 , Alt+Enter <code>dialog:next-entry</code> Right <code>dialog:previous-entry</code> Left <code>dialog:select</code> Enter , Num Enter <code>dialog:select-no</code> Esc <code>doc:backspace</code> Shift+Backspace , Backspace <code>doc:copy</code> Ctrl+Ins , Ctrl+C <code>doc:create-cursor-next-line</code> Ctrl+Shift+Down <code>doc:create-cursor-previous-line</code> Ctrl+Shift+Up <code>doc:cut</code> Ctrl+X <code>doc:delete</code> Shift+Del , Del <code>doc:delete-lines</code> Ctrl+Shift+K <code>doc:delete-to-next-word-end</code> Ctrl+Del , Ctrl+Shift+Del <code>doc:delete-to-previous-word-start</code> Ctrl+Shift+Backspace , Ctrl+Backspace <code>doc:duplicate-lines</code> Ctrl+Shift+D <code>doc:go-to-line</code> Ctrl+G <code>doc:indent</code> Tab <code>doc:join-lines</code> Ctrl+J <code>doc:move-lines-down</code> Ctrl+Down <code>doc:move-lines-up</code> Ctrl+Up <code>doc:move-to-end-of-doc</code> Ctrl+End <code>doc:move-to-end-of-line</code> End <code>doc:move-to-next-block-end</code> Ctrl+] <code>doc:move-to-next-char</code> Right <code>doc:move-to-next-line</code> Down <code>doc:move-to-next-page</code> Page Down <code>doc:move-to-next-word-end</code> Ctrl+Right <code>doc:move-to-previous-block-start</code> Ctrl+[ <code>doc:move-to-previous-char</code> Left <code>doc:move-to-previous-line</code> Up <code>doc:move-to-previous-page</code> Page Up <code>doc:move-to-previous-word-start</code> Ctrl+Left <code>doc:move-to-start-of-doc</code> Ctrl+Home <code>doc:move-to-start-of-indentation</code> Home <code>doc:newline</code> Enter , Num Enter <code>doc:newline-above</code> Ctrl+Shift+Enter <code>doc:newline-below</code> Ctrl+Enter <code>doc:paste</code> Shift+Ins , Ctrl+V <code>doc:redo</code> Ctrl+Y <code>doc:save</code> Ctrl+S <code>doc:save-as</code> Ctrl+Shift+S <code>doc:select-all</code> Ctrl+A <code>doc:select-lines</code> Ctrl+L <code>doc:select-none</code> Esc <code>doc:select-to-cursor</code> Shift+Left Button <code>doc:select-to-end-of-doc</code> Ctrl+Shift+End <code>doc:select-to-end-of-line</code> Shift+End <code>doc:select-to-next-block-end</code> Ctrl+Shift+] <code>doc:select-to-next-char</code> Shift+Right <code>doc:select-to-next-line</code> Shift+Down <code>doc:select-to-next-page</code> Shift+Page Down <code>doc:select-to-next-word-end</code> Ctrl+Shift+Right <code>doc:select-to-previous-block-start</code> Ctrl+Shift+[ <code>doc:select-to-previous-char</code> Shift+Left <code>doc:select-to-previous-line</code> Shift+Up <code>doc:select-to-previous-page</code> Shift+Page Up <code>doc:select-to-previous-word-start</code> Ctrl+Shift+Left <code>doc:select-to-start-of-doc</code> Ctrl+Shift+Home <code>doc:select-to-start-of-indentation</code> Shift+Home <code>doc:select-word</code> Ctrl+Shift+L , Ctrl+D <code>doc:set-cursor</code> Left Button <code>doc:set-cursor-line</code> Left Button <code>doc:set-cursor-word</code> Left Button <code>doc:split-cursor</code> Ctrl+Left Button <code>doc:toggle-block-comments</code> Ctrl+Shift+/ <code>doc:toggle-line-comments</code> Ctrl+/ <code>doc:undo</code> Ctrl+Z <code>doc:unindent</code> Shift+Tab <code>find-replace:find</code> Ctrl+F <code>find-replace:previous-find</code> Shift+F3 <code>find-replace:repeat-find</code> F3 <code>find-replace:replace</code> Ctrl+R <code>find-replace:select-add-all</code> Ctrl+Shift+L <code>find-replace:select-add-next</code> Ctrl+D <code>find-replace:select-next</code> Ctrl+F3 <code>find-replace:select-previous</code> Ctrl+Shift+F3 <code>find-replace:toggle-regex</code> Ctrl+Shift+I <code>find-replace:toggle-sensitivity</code> Ctrl+I <code>line-wrapping:toggle</code> F10 <code>macro:play</code> Ctrl+; <code>macro:toggle-record</code> Ctrl+Shift+; <code>project-search:find</code> Ctrl+Shift+F <code>project-search:move-to-end-of-doc</code> Ctrl+End , End <code>project-search:move-to-next-page</code> Page Down <code>project-search:move-to-previous-page</code> Page Up <code>project-search:move-to-start-of-doc</code> Ctrl+Home , Home <code>project-search:open-selected</code> Enter <code>project-search:refresh</code> F5 <code>project-search:select-next</code> Down <code>project-search:select-previous</code> Up <code>quote:quote</code> Ctrl+' <code>reflow:reflow</code> Ctrl+Shift+Q <code>root:close</code> Ctrl+W <code>root:horizontal-scroll</code> Shift+Wheel , Horizontal Wheel <code>root:move-tab-left</code> Ctrl+Page Up <code>root:move-tab-right</code> Ctrl+Page Down <code>root:scroll</code> Wheel <code>root:split-down</code> Shift+Alt+K <code>root:split-left</code> Shift+Alt+J <code>root:split-right</code> Shift+Alt+L <code>root:split-up</code> Shift+Alt+I <code>root:switch-to-down</code> Alt+K <code>root:switch-to-left</code> Alt+J <code>root:switch-to-next-tab</code> Ctrl+Tab <code>root:switch-to-previous-tab</code> Ctrl+Shift+Tab <code>root:switch-to-right</code> Alt+L <code>root:switch-to-tab-1</code> Alt+1 <code>root:switch-to-tab-2</code> Alt+2 <code>root:switch-to-tab-3</code> Alt+3 <code>root:switch-to-tab-4</code> Alt+4 <code>root:switch-to-tab-5</code> Alt+5 <code>root:switch-to-tab-6</code> Alt+6 <code>root:switch-to-tab-7</code> Alt+7 <code>root:switch-to-tab-8</code> Alt+8 <code>root:switch-to-tab-9</code> Alt+9 <code>root:switch-to-up</code> Alt+I <code>scale:decrease</code> Ctrl+- , Ctrl+Wheel Down <code>scale:increase</code> Ctrl+= , Ctrl+Wheel Up <code>scale:reset</code> Ctrl+0 <code>treeview:collapse</code> Left <code>treeview:delete</code> Del <code>treeview:deselect</code> Esc <code>treeview:expand</code> Right <code>treeview:new-folder</code> Ctrl+Left Button , Ctrl+Enter <code>treeview:next</code> Down <code>treeview:open</code> Enter <code>treeview:previous</code> Up <code>treeview:select</code> Middle Button <code>treeview:select-and-open</code> Left Button <code>treeview:toggle</code> Ctrl+\\"},{"location":"user-guide/lsp/","title":"Language Server support","text":"<p>Many text editors support \"Intellisense\" (error reporting, smart autocompletion, formatting, linting) out-of-the-box with a language server client. Language Server Protocol is a protocol developed by Microsoft to facilitate creating tooling that  are separate from editors \u2014 unlike in a traditional IDE where tooling is directly integrated into the editor.</p> <p>Lite XL does not provide a language server client, but the functionality is available via the LSP plugin. In this article, we will discuss how to properly set up language servers for use with the plugin.</p>"},{"location":"user-guide/lsp/#installation","title":"Installation","text":"<p>The LSP plugin can be installed like any other Lite XL plugins.</p> <p>The LSP plugin depends on the widget and optionally lint+ and lsp_snippets plugin for rendering UI elements. When installing the plugin manually, you must also install these plugins as well.</p> lpmMiqManual Installation <p>To install LPM via the command line, run: <pre><code>$ lpm plugin install lsp\n</code></pre></p> <p>To install LSP via Miq, add <code>lite-xl/lite-xl-lsp</code> into your <code>config.plugins.miq.plugins</code>:</p> <pre><code>local config = require \"core.config\"\nconfig.plugins.miq.plugins = {\n-- this allows Miq to manage itself\n'TorchedSammy/Miq',\n\n-- install lsp\n'lite-xl/lite-xl-lsp',\n}\n</code></pre> <p>Afterwards, run the command <code>miq:install</code> to begin installation.</p> <p>To install the LSP plugin manually, run these commands:</p> <pre><code>$ cd ~/.config/lite-xl/\n$ git clone https://github.com/lite-xl/lite-xl-lsp plugins/lsp\n$ git clone https://github.com/lite-xl/lite-xl-widgets libraries/widget\n$ git clone https://github.com/liquidev/lintplus plugins/lintplus\n$ wget https://raw.githubusercontent.com/vqns/lite-xl-snippets/main/snippets.lua \\\n    -O plugins/snippets.lua\n$ wget https://raw.githubusercontent.com/vqns/lite-xl-snippets/main/lsp_snippets.lua \\\n    -O plugins/lsp_snippets.lua\n</code></pre> <p>They install the plugin with all its dependencies.</p>"},{"location":"user-guide/lsp/#installing-language-servers","title":"Installing Language Servers","text":"<p>The LSP plugin requires languages servers to be installed on the system to function. Some editors such as Visual Studio Code and Neovim tends to have this process abstracted by plugins. Luckily, Lite XL provides commonly-used language servers as plugins as well, prefixed with <code>lsp_</code>.</p> Plugin Language(s) Server Platforms lsp_c C, C++, Objective-C clangd Linux, macOS, Windows lsp_lua Lua LuaLS Linux, macOS, Windows lsp_python Python Pyright Linux, macOS, Windows lsp_quicklintjs JavaScript quick-lint-js Linux, macOS, Windows lsp_rust Rust rust-analyzer Linux, macOS, Windows lsp_tex TeX texlab Linux, macOS, Windows lsp_zig Zig zls Linux, macOS, Windows"},{"location":"user-guide/lsp/#manual-installation","title":"Manual Installation","text":"<p>The LSP plugin expects language servers to be accessible in <code>PATH</code>. If you have installed the language server from package managers such as <code>npm</code> and <code>pip</code>, please ensure that their local installation directory is in <code>PATH</code>.</p> <p>Important</p> <p>Even more care needs to be given to those who uses a node.js version manager such as nvm, as the npm prefix changes when switching node.js versions. You should always launch Lite XL after sourcing nvm (do this for any Lite XL's desktop entries as well).</p>"},{"location":"user-guide/lsp/#set-up","title":"Set Up","text":"<p>If you installed the language servers via plugins, then you should skip this step.</p> <p>The LSP plugin provides default configuration for most language servers, based on nvim-lspconfig. These configurations are available by requiring <code>plugins.lsp.config</code> in your user module. For example, to configure typescript-language-server, you can do:</p> <pre><code>local lspconfig = require \"plugins.lsp.config\"\n\n-- set up typescript-language-server with default configuration (enough for most people)\nlspconfig.tsserver.setup()\n\n-- override the default configuration\nlspconfig.tsserver.setup {\n    verbose = false\n}\n</code></pre>"},{"location":"user-guide/lsp/#features","title":"Features","text":"<p>After configuring your language server, you should see a log message in the form of <code>[LSP] starting (language server name)</code> followed by <code>[(language server name)] Initialized</code> when opening a file supported by the language server. These messages indicate that the language server is properly set up and is running for the document.</p>"},{"location":"user-guide/lsp/#enhanced-autocomplete","title":"Enhanced Autocomplete","text":"<p>One of the most prominent features of a language server is to provide autocomplete suggestions. The LSP plugin integrates with the autocomplete plugin to provide this functionality.</p> <p></p>"},{"location":"user-guide/lsp/#snippets","title":"Snippets","text":"<p>When installed with lsp_snippets, the LSP plugin is able to provide snippets from language servers. The snippets are also integrated with the autocomplete plugin.</p> <p></p>"},{"location":"user-guide/lsp/#inline-diagnostics","title":"Inline Diagnostics","text":"<p>When installed with lint+, the LSP plugin will show diagnostics on the affected lines. You can disable this with <code>lsp:toggle-diagnostics</code> (Shift+Alt+E).</p> <p></p>"},{"location":"user-guide/lsp/#symbol-search","title":"Symbol Search","text":"<p>To view all symbols in a file, you can use <code>lsp:view-document-symbols</code> (Alt+S). You can use <code>lsp:find-workspace-symbol</code> (Shift+Alt+S) to find a symbol in the current workspace.</p> <p> </p>"},{"location":"user-guide/lsp/#tooltips","title":"Tooltips","text":"<p>You can hover on symbols to check their types and descriptions.</p> <p></p> <p>Tooltips will also appear when entering function arguments.</p> <p></p>"},{"location":"user-guide/lsp/#go-to-definition","title":"Go to Definition","text":"<p>Press Alt+D to jump to definition.</p> <p></p>"},{"location":"user-guide/lsp/#find-references","title":"Find References","text":"<p>Press Alt+F to find references to a symbol.</p> <p></p>"},{"location":"user-guide/lsp/#document-formatting","title":"Document Formatting","text":"<p>Press Alt+Shift+F to format the current document.</p> <p></p>"},{"location":"user-guide/lsp/#diagnostics","title":"Diagnostics","text":"<p>Press Alt+E to view diagnostics messages for the current document. Press Ctrl+Alt+E to view diagnostics messages for the workspace.</p> <p> </p>"},{"location":"user-guide/lsp/#troubleshooting","title":"Troubleshooting","text":"<p>We are constantly updating the LSP plugin to fix bugs, add features and improve performance. If you encounter any issues, you should always update to the latest version before trying other steps.</p>"},{"location":"user-guide/lsp/#enable-debug-logging","title":"Enable Debug Logging","text":"<p>If you encounter an error message such as <code>[LSP] (language server name) was shutdown, revise your configuration</code>, you should try to enable debug logging to see what is happening when the language server is run.</p> <p>This is very useful on Windows as the plugin runs the language server with <code>cmd.exe</code> (to work around wrappers like those provided by npm) and this can cause errors to never propagate back to the plugin.</p> User ModuleSettings GUI <p>In your user module, add:</p> <pre><code>config.plugins.lsp.log_server_stderr = true\n</code></pre> <p>Navigate to the \"Plugins\" tab. Under the \"Language Server Protocol\" section, enable \"Log Standard Error\".</p> <p></p>"},{"location":"user-guide/lsp/#language-servers-not-starting","title":"Language Servers not starting","text":"<p>There are many reasons why a language server will not launch, the most common being the plugin cannot find the language server in <code>PATH</code>.</p> <p>On Windows, this often manifests as  <code>(language server name) is not recognized as an internal or external command, operable program or batch file.</code>. The LSP plugin uses <code>cmd.exe</code> on Windows to launch the language server in order to work around different file extensions such as <code>.cmd</code>, <code>.bat</code> and <code>.exe</code>.</p> <p>To solve this issue, make sure that the language server is on <code>PATH</code>. For non-native language servers (e.g. typescript-language-server), make sure their installation path with respect to the package managers are on <code>PATH</code> as well. For npm, this is usually <code>AppData\\Roaming\\npm</code> on Windows.</p>"},{"location":"user-guide/lsp/#jdtls-launches-microsoft-store","title":"jdt.ls launches Microsoft Store","text":"<p>If you've installed jdt.ls from their website, you might run into issues where Microsoft Store is launched instead of running the language server properly.</p> <p>jdt.ls seems to expect users to have Python installed, and Windows has app execution aliases built in to redirect <code>python.exe</code> and <code>python3.exe</code> to Microsoft Store.</p> <p></p> <p>To fix this, install Python. Alternatively, you can follow the instructions from jdt.ls to run the language server without Python at all.</p>"},{"location":"user-guide/macos-keymap/","title":"macOS Keymap","text":"<p>This is the default keyboard shortcuts on macOS. Your configuration may differ as plugins can modify them.</p> Command Keys <code>autocomplete:cancel</code> Esc <code>autocomplete:complete</code> Tab <code>autocomplete:next</code> Down <code>autocomplete:previous</code> Up <code>command:complete</code> Tab <code>command:escape</code> Esc <code>command:select-next</code> Down <code>command:select-previous</code> Up <code>command:submit</code> Num Enter , Enter <code>context:focus-next</code> Down <code>context:focus-previous</code> Up <code>context:hide</code> Esc <code>context:on-selected</code> Enter <code>context:show</code> Menu <code>core:change-project-folder</code> Shift+Cmd+C <code>core:find-command</code> Shift+Cmd+P <code>core:find-file</code> Cmd+P <code>core:new-doc</code> Cmd+N <code>core:open-file</code> Cmd+O <code>core:open-project-folder</code> Shift+Cmd+O <code>core:restart</code> Option+Cmd+R <code>core:toggle-fullscreen</code> Ctrl+Cmd+Enter <code>dialog:next-entry</code> Right <code>dialog:previous-entry</code> Left <code>dialog:select</code> Num Enter , Enter <code>dialog:select-no</code> Esc <code>doc:backspace</code> Backspace , Shift+Backspace <code>doc:copy</code> Ctrl+Ins , Cmd+C <code>doc:create-cursor-next-line</code> Option+Cmd+Down <code>doc:create-cursor-previous-line</code> Option+Cmd+Up <code>doc:cut</code> Cmd+X <code>doc:delete</code> Del , Shift+Del <code>doc:delete-lines</code> Shift+Cmd+K <code>doc:delete-to-end-of-line</code> Cmd+Del <code>doc:delete-to-next-word-end</code> Shift+Cmd+Del , Option+Del <code>doc:delete-to-previous-word-start</code> Shift+Cmd+Backspace , Option+Backspace <code>doc:delete-to-start-of-indentation</code> Cmd+Backspace <code>doc:duplicate-lines</code> Shift+Cmd+D <code>doc:go-to-line</code> Cmd+G <code>doc:indent</code> Tab <code>doc:join-lines</code> Cmd+J <code>doc:move-lines-down</code> Option+Down <code>doc:move-lines-up</code> Option+Up <code>doc:move-to-end-of-doc</code> Cmd+Down <code>doc:move-to-end-of-line</code> End , Cmd+Right <code>doc:move-to-next-block-end</code> Cmd+] <code>doc:move-to-next-char</code> Right <code>doc:move-to-next-line</code> Down <code>doc:move-to-next-page</code> Page Down <code>doc:move-to-next-word-end</code> Option+Right <code>doc:move-to-previous-block-start</code> Cmd+[ <code>doc:move-to-previous-char</code> Left <code>doc:move-to-previous-line</code> Up <code>doc:move-to-previous-page</code> Page Up <code>doc:move-to-previous-word-start</code> Option+Left <code>doc:move-to-start-of-doc</code> Cmd+Up <code>doc:move-to-start-of-indentation</code> Cmd+Left , Home <code>doc:newline</code> Num Enter , Enter <code>doc:newline-above</code> Shift+Cmd+Enter <code>doc:newline-below</code> Cmd+Enter <code>doc:paste</code> Shift+Ins , Cmd+V <code>doc:redo</code> Cmd+Y <code>doc:save</code> Cmd+S <code>doc:save-as</code> Shift+Cmd+S <code>doc:select-all</code> Cmd+A <code>doc:select-lines</code> Cmd+L <code>doc:select-none</code> Esc <code>doc:select-to-cursor</code> Shift+Left Button <code>doc:select-to-end-of-doc</code> Shift+Cmd+Down <code>doc:select-to-end-of-line</code> Shift+End , Shift+Cmd+Right <code>doc:select-to-next-block-end</code> Shift+Cmd+] <code>doc:select-to-next-char</code> Shift+Right <code>doc:select-to-next-line</code> Shift+Down <code>doc:select-to-next-page</code> Shift+Page Down <code>doc:select-to-next-word-end</code> Option+Shift+Right <code>doc:select-to-previous-block-start</code> Shift+Cmd+[ <code>doc:select-to-previous-char</code> Shift+Left <code>doc:select-to-previous-line</code> Shift+Up <code>doc:select-to-previous-page</code> Shift+Page Up <code>doc:select-to-previous-word-start</code> Option+Shift+Left <code>doc:select-to-start-of-doc</code> Shift+Cmd+Up <code>doc:select-to-start-of-indentation</code> Shift+Home , Shift+Cmd+Left <code>doc:select-word</code> Shift+Cmd+L , Cmd+D <code>doc:set-cursor</code> Left Button <code>doc:set-cursor-line</code> Left Button <code>doc:set-cursor-word</code> Left Button <code>doc:split-cursor</code> Ctrl+Left Button <code>doc:toggle-line-comments</code> Cmd+/ <code>doc:undo</code> Cmd+Z <code>doc:unindent</code> Shift+Tab <code>find-replace:find</code> Cmd+F <code>find-replace:previous-find</code> Shift+F3 <code>find-replace:repeat-find</code> F3 <code>find-replace:replace</code> Cmd+R <code>find-replace:select-add-all</code> Shift+Cmd+L <code>find-replace:select-add-next</code> Cmd+D <code>find-replace:select-next</code> Cmd+F3 <code>line-wrapping:toggle</code> F10 <code>macro:play</code> Cmd+; <code>macro:toggle-record</code> Shift+Cmd+; <code>project-search:find</code> Shift+Cmd+F <code>project-search:move-to-end-of-doc</code> Cmd+End , End <code>project-search:move-to-next-page</code> Page Down <code>project-search:move-to-previous-page</code> Page Up <code>project-search:move-to-start-of-doc</code> Home , Cmd+Home <code>project-search:open-selected</code> Enter <code>project-search:refresh</code> F5 <code>project-search:select-next</code> Down <code>project-search:select-previous</code> Up <code>quote:quote</code> Cmd+' <code>reflow:reflow</code> Ctrl+Shift+Q <code>root:close-or-quit</code> Cmd+W <code>root:horizontal-scroll</code> Horizontal Wheel , Shift+Horizontal Wheel <code>root:move-tab-left</code> Cmd+Page Up <code>root:move-tab-right</code> Cmd+Page Down <code>root:scroll</code> Wheel <code>root:split-down</code> Ctrl+Shift+Cmd+K <code>root:split-left</code> Ctrl+Shift+Cmd+J <code>root:split-right</code> Ctrl+Shift+Cmd+L <code>root:split-up</code> Ctrl+Shift+Cmd+I <code>root:switch-to-down</code> Ctrl+Cmd+K <code>root:switch-to-left</code> Ctrl+Cmd+J <code>root:switch-to-next-tab</code> Ctrl+Tab <code>root:switch-to-previous-tab</code> Ctrl+Shift+Tab <code>root:switch-to-right</code> Ctrl+Cmd+L <code>root:switch-to-tab-1</code> Cmd+1 <code>root:switch-to-tab-2</code> Cmd+2 <code>root:switch-to-tab-3</code> Cmd+3 <code>root:switch-to-tab-4</code> Cmd+4 <code>root:switch-to-tab-5</code> Cmd+5 <code>root:switch-to-tab-6</code> Cmd+6 <code>root:switch-to-tab-7</code> Cmd+7 <code>root:switch-to-tab-8</code> Cmd+8 <code>root:switch-to-tab-9</code> Cmd+9 <code>root:switch-to-up</code> Ctrl+Cmd+I <code>scale:decrease</code> Cmd+- , Cmd+Wheel Down <code>scale:increase</code> Cmd+= , Cmd+Wheel Up <code>scale:reset</code> Cmd+0 <code>treeview:collapse</code> Left <code>treeview:delete</code> Del <code>treeview:deselect</code> Esc <code>treeview:expand</code> Right <code>treeview:new-folder</code> Cmd+Enter , Cmd+Left Button <code>treeview:next</code> Down <code>treeview:open</code> Enter <code>treeview:previous</code> Up <code>treeview:select</code> Middle Button <code>treeview:select-and-open</code> Left Button <code>treeview:toggle</code> Cmd+\\"},{"location":"user-guide/managing-plugins/","title":"Managing Plugins","text":"<p>Lite XL implements many features as plugins. By default, Lite XL comes with a few built-in plugins for essential features such as treeview and workspace, while the Addons package provides more. All plugins can be found at the plugin repository.</p> <p>Note</p> <p>These plugins are contributed by the community. Support are provided on a voluntary basis.</p>"},{"location":"user-guide/managing-plugins/#location","title":"Location","text":"<p>Plugins that come bundled with Lite XL is usually stored in <code>DATADIR/plugins</code>. <code>DATADIR</code> is the directory where Lite XL's Lua code is stored.</p> <p>On macOS, <code>DATADIR</code> is always the application resources directory. On other platforms, Lite XL checks whether <code>lite-xl.exe</code> is inside a directory called <code>bin</code>. If true, Lite XL will set <code>DATADIR</code> as <code>(path to lite-xl.exe)/../share/lite-xl</code>. This is similar to how most programs are structured on Unix-based platforms. Otherwise, Lite XL sets <code>DATADIR</code> as <code>(path to lite-xl.exe)/data</code>.</p> <p>User plugins should be installed into <code>USERDIR/plugins</code>. <code>USERDIR</code> is the directory where user configuration is stored.</p>"},{"location":"user-guide/managing-plugins/#plugin-managers","title":"Plugin managers","text":"<p>Recently, we've standardized various aspects of the plugin repository to allow for plugins manager such as lpm and Miq to install and manage plugins.</p> <p>lpm is a plugin manager more akin to distro package managers such as <code>apt</code> and <code>dnf</code>. It also provides a GUI for installing plugins. Miq is a declarative plugin manager that allows user to declare plugins and install/update them all at once.</p> <p>These two plugin managers use vastly different ways of plugin management,  so please consult the main page for each plugin manager for exact instructions.</p>"},{"location":"user-guide/managing-plugins/#installing-plugins","title":"Installing plugins","text":"<p>To install a plugin, simply drag the related plugin file into <code>USERDIR/plugins</code>.</p> For plugins that comes in a folder, please consult documentation from the plugins. <p>Historically, Lite XL does not enforce a specific file structure for these types of plugins. Old plugins may not have a <code>init.lua</code> file, which is used by Lua to find a plugin. In this case, you need to follow their install instructions.</p> lpmMiq <p>To install a plugin with lpm, use <code>lpm plugin install</code>. For example, to install lsp, run:</p> <pre><code>$ lpm plugin install lsp\n</code></pre> <p>This will install/update the lsp plugin.</p> <p>To install themes or libraries, you can use <code>lpm color install</code> and <code>lpm library install</code> respectively.</p> <p>To install a plugin with Miq, you need to specify the list of plugins to install in <code>config.plugins.miq.plugins</code>.</p> <pre><code>local config = require \"core.config\"\nconfig.plugins.miq.plugins = {\n  -- this allows Miq to manage itself\n  'TorchedSammy/Miq',\n\n  -- install lsp\n  'lite-xl/lite-xl-lsp',\n}\n</code></pre> <p>Afterwards, you can run the command <code>miq:install</code> to install the plugins.</p>"},{"location":"user-guide/managing-plugins/#updating-plugins","title":"Updating plugins","text":"<p>To update a plugin, you'll need to re-download them. For plugins hosted as separate git repositories, you can simply pull new updates.</p> <p>If you have a plugin manager installed, updating plugins should be easier.</p> lpmMiq <p>To update plugins with lpm, run <code>lpm upgrade</code>.</p> <pre><code>$ lpm upgrade\n</code></pre> <p>This will update all the plugins to their latest versions.</p> <p>To update plugins with Miq, run \"miq:update\".</p>"},{"location":"user-guide/managing-plugins/#uninstalling-plugins","title":"Uninstalling plugins","text":"<p>To remove a plugin, simply delete the associated file/directory.</p> lpmMiq <p>To uninstall a plugin, run <code>lpm plugin uninstall</code>. For instance, to uninstall lsp, run:</p> <pre><code>$ lpm plugin uninstall lsp\n</code></pre> <p>Uninstalling themes and libraries can be done with <code>lpm color uninstall</code> and <code>lpm library uninstall</code> respectively.</p> <p>Uninstalling plugins in Miq is currently not supported.</p>"},{"location":"user-guide/managing-plugins/#recommended-plugins","title":"Recommended plugins","text":"<p>Here are a list of plugins that most users would want:</p> Plugin Use case align_carets Align text on multiple carets and selections autoinsert Automatically insert closing brackets and quotes autosave Automatically saves the file when it is modified bracketmatch Highlight matching brackets editorconfig EditorConfig support for Lite XL ephemeral_tabs Ephemeral tabs (previewing files without creating multiple tabs) gitdiff_highlight Git diff gutter indentguide Indent guides lint+ Linter support litepresence Discord rich presence lsp Language Server support for Lite XL lspkind Completion menu kind/type icons for Lite XL LSP minimap Minimap selectionhighlight Highlight code that matches the selection settings Settings GUI for Lite XL (requires the [widget] plugin) widgets Widget toolkit for Lite XL. Needed for lsp and settings."},{"location":"user-guide/managing-plugins/#feature-plugin-requests","title":"Feature / Plugin Requests","text":"<p>If no plugins provide the features you wanted, you can request them in the issue tracker. Plugin developers occasionally browse the issue tracker for requests and implement them.</p> <p>Alternatively, you can take the opportunity to implement the feature yourself, based on various documentation and existing plugins.</p>"}]}